//==========================================================================
// Copyright (C) 2023-2024 CERN
// Licensed under the GNU Lesser General Public License (version 3 or later).
// Written by: Z. Wettersten (Jan 2024) for the MG5aMC CUDACPP plugin.
//==========================================================================
//==========================================================================
// Library including generic functions and classes for event reweighting.
// Process-specific rwgt_runner files are generated by mg5amc@nlo and use
// this library, while the rwgt_driver file is a wrapping program that 
// calls the process-specific runners for given subprocesses.
//==========================================================================

#ifndef _RWGT_INSTANCE_CC_
#define _RWGT_INSTANCE_CC_

#include "rwgt_instance.h"

namespace rwgt{


    //ZW: Function for calculating the number of remaining events in a warp
    // in order to pad the input arrays to a multiple of the warp size
    unsigned int warpRemain( unsigned int nEvt, unsigned int nWarp ){
        return (nWarp - ( nEvt % nWarp )) % nWarp;
    }

    //ZW: Function for padding the input arrays to a multiple of the warp size
    template<typename T>
    std::shared_ptr<std::vector<T>> warpPad( std::vector<T>& input, unsigned int nWarp = 32 ){
        auto nEvt = input->size();
        auto nWarpRemain = warpRemain( nEvt, nWarp );
        auto fauxNEvt = nEvt + nWarpRemain;
        auto output = std::make_shared<std::vector<T>>( fauxNEvt );
        std::copy( input.begin(), input.end(), output->begin());
        return output;
    }

        instance::instance(){}
        instance::instance( std::vector<std::pair<int,int>>& event){
            this->procEventInt = event;
            this->process = REX::event( event );
        }
        instance::instance( std::vector<std::pair<int,int>>& event, REX::teaw::amplitude& amp ){
            this->procEventInt = event;
            this->process = REX::event( event );
            bridgeCall = amp;
        }
        void instance::setProc( std::vector<std::pair<int,int>>& event ){
            this->procEventInt = event;
            this->process = REX::event( event );
        }
        instance::instance( std::vector<std::pair<std::string,std::string>>& event){
            this->procEventStr = event;
            this->process = REX::event( event );
        }
        instance::instance( std::vector<std::pair<std::string,std::string>>& event, REX::teaw::amplitude& amp ){
            this->procEventStr = event;
            this->process = REX::event( event );
            bridgeCall = amp;
        }
        void instance::setProc( std::vector<std::pair<std::string,std::string>>& event ){
            this->procEventStr = event;
            this->process = REX::event( event );
        }
        void instance::setAmp( REX::teaw::amplitude& amp ){
            bridgeCall = amp;
        }
        std::shared_ptr<std::vector<FORTRANFPTYPE>> instance::ampEval( std::vector<double>& momenta, std::vector<double>& alphaS ){
            return bridgeCall( momenta, alphaS );
        }
        std::shared_ptr<std::vector<FORTRANFPTYPE>> instance::ampEval( std::shared_ptr<std::vector<double>> momenta, 
        std::shared_ptr<std::vector<double>> alphaS ){
            return bridgeCall( *momenta, *alphaS );
        }

}

#endif
