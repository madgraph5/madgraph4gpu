//==========================================================================
// Copyright (C) 2023-2024 CERN
// Licensed under the GNU Lesser General Public License (version 3 or later).
// Written by: Z. Wettersten (Jan 2024) for the MG5aMC CUDACPP plugin.
//==========================================================================
//==========================================================================
// Library including generic functions and classes for event reweighting.
// Process-specific rwgt_runner files are generated by mg5amc@nlo and use
// this library, while the rwgt_driver file is a wrapping program that 
// calls the process-specific runners for given subprocesses.
//==========================================================================

#ifndef _RWGT_INSTANCE_H_
#define _RWGT_INSTANCE_H_

#include "teawREX.hpp"

namespace rwgt{

    //ZW: Function for calculating the number of remaining events in a warp
    // in order to pad the input arrays to a multiple of the warp size
    unsigned int warpRemain( unsigned int nEvt, unsigned int nWarp = 32 ){
        return (nWarp - ( nEvt % nWarp )) % nWarp;
    }

    //ZW: Function for padding the input arrays to a multiple of the warp size
    template<typename T>
    std::shared_ptr<std::vector<T>> warpPad( std::vector<T>& input, unsigned int nWarp = 32 ){
        auto nEvt = input->size();
        auto nWarpRemain = warpRemain( nEvt, nWarp );
        auto fauxNEvt = nEvt + nWarpRemain;
        auto output = std::make_shared<std::vector<T>>( fauxNEvt );
        std::copy( input.begin(), input.end(), output->begin());
        return output;
    }

    struct instance{
        std::vector<std::pair<int,int>> procEvent;
        REX::event process;
        REX::teaw::amplitude bridgeCall;
        instance(){}
        instance( std::vector<std::pair<int,int>>& event){
            this->procEvent = event;
            this->process = REX::event( event );
        }
        instance( std::vector<std::pair<int,int>>& event, REX::teaw::amplitude& amp ){
            this->procEvent = event;
            this->process = REX::event( event );
            bridgeCall = amp;
        }
        void setProc( std::vector<std::pair<int,int>>& event ){
            this->procEvent = event;
            this->process = REX::event( event );
        }
        void setAmp( REX::teaw::amplitude& amp ){
            bridgeCall = amp;
        }
        std::shared_ptr<std::vector<FORTRANFPTYPE>> ampEval( std::vector<double>& momenta, std::vector<double>& alphaS ){
            return bridgeCall( momenta, alphaS );
        }
        std::shared_ptr<std::vector<FORTRANFPTYPE>> ampEval( std::shared_ptr<std::vector<double>> momenta, 
        std::shared_ptr<std::vector<double>> alphaS ){
            return bridgeCall( *momenta, *alphaS );
        }
    };

}

#endif