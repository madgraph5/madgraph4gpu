// Copyright (C) 2020-2025 CERN and UCLouvain.
// Licensed under the GNU Lesser General Public License (version 3 or later).
// Created by: A. Valassi (Sep 2025) for the MG5aMC CUDACPP plugin.
// Further modified by: A. Valassi (2025) for the MG5aMC CUDACPP plugin.

/* clang-format off */

  //--------------------------------------------------------------------------

  __global__ void
  diagram1( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
            fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
            const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
            const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
            const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
            fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
            fptype* denominators,           // input/output: multichannel denominators[nevtORneppV], add helicity ihel
            const fptype* momenta,          // input: momenta[npar*4*nevtORneppV]
            const int ihel )                // input: helicity (0 to ncomb)
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
#ifdef MGONGPUCPP_GPUIMPL
    using M_ACCESS = DeviceAccessMomenta; // non-trivial access: buffer includes all events
#else
    using M_ACCESS = HostAccessMomenta; // non-trivial access: buffer includes all events
#endif
    // *** DIAGRAM 1 OF 1240 ***
    // Wavefunction(s) for diagram number 1
    vxxxxx<M_ACCESS, W_ACCESS>( momenta, 0., cHel[ihel][0], -1, w_fp[0], 0 );
    vxxxxx<M_ACCESS, W_ACCESS>( momenta, 0., cHel[ihel][1], -1, w_fp[1], 1 );
    oxxxxx<M_ACCESS, W_ACCESS>( momenta, cIPD[0], cHel[ihel][2], +1, w_fp[2], 2 );
    ixxxxx<M_ACCESS, W_ACCESS>( momenta, cIPD[0], cHel[ihel][3], -1, w_fp[3], 3 );
    vxxxxx<M_ACCESS, W_ACCESS>( momenta, 0., cHel[ihel][4], +1, w_fp[4], 4 );
    vxxxxx<M_ACCESS, W_ACCESS>( momenta, 0., cHel[ihel][5], +1, w_fp[5], 5 );
    vxxxxx<M_ACCESS, W_ACCESS>( momenta, 0., cHel[ihel][6], +1, w_fp[6], 6 );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], COUPs[0], 1.0, 0., 0., w_fp[7] );
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[2], COUPs[1], 1.0, 0., 0., w_fp[8] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[9] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[10] );
    // Amplitude(s) for diagram number 1
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[9], w_fp[10], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram2( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
            fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
            const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
            const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
            const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
            fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
            fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 2 OF 1240 ***
    // Wavefunction(s) for diagram number 2
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[11] );
    // Amplitude(s) for diagram number 2
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[9], w_fp[11], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram3( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
            fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
            const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
            const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
            const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
            fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
            fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 3 OF 1240 ***
    // Wavefunction(s) for diagram number 3
    // (none)
    // Amplitude(s) for diagram number 3
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[6], w_fp[9], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[6], w_fp[9], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[6], w_fp[9], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram4( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
            fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
            const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
            const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
            const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
            fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
            fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 4 OF 1240 ***
    // Wavefunction(s) for diagram number 4
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[12] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[13] );
    // Amplitude(s) for diagram number 4
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[13], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram5( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
            fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
            const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
            const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
            const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
            fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
            fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 5 OF 1240 ***
    // Wavefunction(s) for diagram number 5
    // (none)
    // Amplitude(s) for diagram number 5
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[11], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram6( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
            fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
            const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
            const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
            const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
            fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
            fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 6 OF 1240 ***
    // Wavefunction(s) for diagram number 6
    // (none)
    // Amplitude(s) for diagram number 6
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[6], w_fp[12], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[6], w_fp[12], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[6], w_fp[12], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram7( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
            fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
            const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
            const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
            const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
            fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
            fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 7 OF 1240 ***
    // Wavefunction(s) for diagram number 7
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[14] );
    // Amplitude(s) for diagram number 7
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[13], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram8( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
            fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
            const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
            const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
            const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
            fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
            fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 8 OF 1240 ***
    // Wavefunction(s) for diagram number 8
    // (none)
    // Amplitude(s) for diagram number 8
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[10], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram9( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
            fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
            const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
            const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
            const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
            fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
            fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 9 OF 1240 ***
    // Wavefunction(s) for diagram number 9
    // (none)
    // Amplitude(s) for diagram number 9
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[5], w_fp[14], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[5], w_fp[14], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[5], w_fp[14], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram10( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 10 OF 1240 ***
    // Wavefunction(s) for diagram number 10
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[4], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[15] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[4], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[16] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[4], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[17] );
    // Amplitude(s) for diagram number 10
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[15], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[16], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[17], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram11( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 11 OF 1240 ***
    // Wavefunction(s) for diagram number 11
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[4], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[18] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[4], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[19] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[4], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[20] );
    // Amplitude(s) for diagram number 11
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[18], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[19], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[20], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram12( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 12 OF 1240 ***
    // Wavefunction(s) for diagram number 12
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[21] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[22] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[23] );
    // Amplitude(s) for diagram number 12
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[21], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[22], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[23], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram13( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 13 OF 1240 ***
    // Wavefunction(s) for diagram number 13
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[4], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[24] );
    // Amplitude(s) for diagram number 13
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[8], w_fp[24], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[8], w_fp[24], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[8], w_fp[24], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram14( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 14 OF 1240 ***
    // Wavefunction(s) for diagram number 14
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[8], COUPs[0], 1.0, 0., 0., w_fp[25] );
    // Amplitude(s) for diagram number 14
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[24], w_fp[6], w_fp[25], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram15( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 15 OF 1240 ***
    // Wavefunction(s) for diagram number 15
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[24], COUPs[0], 1.0, 0., 0., w_fp[26] );
    // Amplitude(s) for diagram number 15
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[26], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram16( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 16 OF 1240 ***
    // Wavefunction(s) for diagram number 16
    // (none)
    // Amplitude(s) for diagram number 16
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[24], w_fp[14], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram17( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 17 OF 1240 ***
    // Wavefunction(s) for diagram number 17
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[4], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[27] );
    // Amplitude(s) for diagram number 17
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[8], w_fp[27], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[8], w_fp[27], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[8], w_fp[27], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram18( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 18 OF 1240 ***
    // Wavefunction(s) for diagram number 18
    // (none)
    // Amplitude(s) for diagram number 18
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[27], w_fp[5], w_fp[25], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram19( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 19 OF 1240 ***
    // Wavefunction(s) for diagram number 19
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[27], COUPs[0], 1.0, 0., 0., w_fp[28] );
    // Amplitude(s) for diagram number 19
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[28], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram20( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 20 OF 1240 ***
    // Wavefunction(s) for diagram number 20
    // (none)
    // Amplitude(s) for diagram number 20
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[27], w_fp[12], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram21( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 21 OF 1240 ***
    // Wavefunction(s) for diagram number 21
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[5], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[29] );
    // Amplitude(s) for diagram number 21
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[8], w_fp[4], w_fp[29], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[8], w_fp[4], w_fp[29], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[8], w_fp[4], w_fp[29], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram22( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 22 OF 1240 ***
    // Wavefunction(s) for diagram number 22
    // (none)
    // Amplitude(s) for diagram number 22
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[4], w_fp[29], w_fp[25], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram23( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 23 OF 1240 ***
    // Wavefunction(s) for diagram number 23
    // (none)
    // Amplitude(s) for diagram number 23
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[29], w_fp[9], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram24( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 24 OF 1240 ***
    // Wavefunction(s) for diagram number 24
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[7], w_fp[29], COUPs[0], 1.0, 0., 0., w_fp[25] );
    // Amplitude(s) for diagram number 24
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[25], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram25( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 25 OF 1240 ***
    // Wavefunction(s) for diagram number 25
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[4], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[30] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[4], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[31] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[4], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[32] );
    // Amplitude(s) for diagram number 25
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[8], w_fp[30], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[8], w_fp[31], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[8], w_fp[32], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram26( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 26 OF 1240 ***
    // Wavefunction(s) for diagram number 26
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[4], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[33] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[7], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[34] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[33], w_fp[5], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[35] );
    // Amplitude(s) for diagram number 26
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[35], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram27( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 27 OF 1240 ***
    // Wavefunction(s) for diagram number 27
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[33], w_fp[6], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[36] );
    // Amplitude(s) for diagram number 27
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[36], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram28( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 28 OF 1240 ***
    // Wavefunction(s) for diagram number 28
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], COUPs[1], 1.0, 0., 0., w_fp[37] );
    // Amplitude(s) for diagram number 28
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[37], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram29( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 29 OF 1240 ***
    // Wavefunction(s) for diagram number 29
    // (none)
    // Amplitude(s) for diagram number 29
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[36], w_fp[12], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram30( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 30 OF 1240 ***
    // Wavefunction(s) for diagram number 30
    // (none)
    // Amplitude(s) for diagram number 30
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[37], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram31( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 31 OF 1240 ***
    // Wavefunction(s) for diagram number 31
    // (none)
    // Amplitude(s) for diagram number 31
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[35], w_fp[14], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram32( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 32 OF 1240 ***
    // Wavefunction(s) for diagram number 32
    // (none)
    // Amplitude(s) for diagram number 32
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[22], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[23], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram33( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 33 OF 1240 ***
    // Wavefunction(s) for diagram number 33
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[5], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[38] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[33], w_fp[7], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[39] );
    // Amplitude(s) for diagram number 33
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[39], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram34( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 34 OF 1240 ***
    // Wavefunction(s) for diagram number 34
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[38], w_fp[7], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[40] );
    // Amplitude(s) for diagram number 34
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[33], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram35( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 35 OF 1240 ***
    // Wavefunction(s) for diagram number 35
    // (none)
    // Amplitude(s) for diagram number 35
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[33], w_fp[14], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram36( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 36 OF 1240 ***
    // Wavefunction(s) for diagram number 36
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[6], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[41] );
    // Amplitude(s) for diagram number 36
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[39], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram37( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 37 OF 1240 ***
    // Wavefunction(s) for diagram number 37
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[41], w_fp[7], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[42] );
    // Amplitude(s) for diagram number 37
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[42], w_fp[33], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram38( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 38 OF 1240 ***
    // Wavefunction(s) for diagram number 38
    // (none)
    // Amplitude(s) for diagram number 38
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[33], w_fp[12], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram39( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 39 OF 1240 ***
    // Wavefunction(s) for diagram number 39
    // (none)
    // Amplitude(s) for diagram number 39
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram40( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 40 OF 1240 ***
    // Wavefunction(s) for diagram number 40
    // (none)
    // Amplitude(s) for diagram number 40
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[33], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram41( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 41 OF 1240 ***
    // Wavefunction(s) for diagram number 41
    // (none)
    // Amplitude(s) for diagram number 41
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[25], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram42( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 42 OF 1240 ***
    // Wavefunction(s) for diagram number 42
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[5], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[39] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[39], w_fp[4], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[43] );
    // Amplitude(s) for diagram number 42
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[43], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram43( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 43 OF 1240 ***
    // Wavefunction(s) for diagram number 43
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[39], w_fp[6], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[44] );
    // Amplitude(s) for diagram number 43
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[44], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram44( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 44 OF 1240 ***
    // Wavefunction(s) for diagram number 44
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], COUPs[1], 1.0, 0., 0., w_fp[45] );
    // Amplitude(s) for diagram number 44
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[9], w_fp[45], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram45( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 45 OF 1240 ***
    // Wavefunction(s) for diagram number 45
    // (none)
    // Amplitude(s) for diagram number 45
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[44], w_fp[9], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram46( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 46 OF 1240 ***
    // Wavefunction(s) for diagram number 46
    // (none)
    // Amplitude(s) for diagram number 46
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[45], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram47( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 47 OF 1240 ***
    // Wavefunction(s) for diagram number 47
    // (none)
    // Amplitude(s) for diagram number 47
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[43], w_fp[14], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram48( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 48 OF 1240 ***
    // Wavefunction(s) for diagram number 48
    // (none)
    // Amplitude(s) for diagram number 48
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[18], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[19], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[20], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram49( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 49 OF 1240 ***
    // Wavefunction(s) for diagram number 49
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[4], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[46] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[39], w_fp[7], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[47] );
    // Amplitude(s) for diagram number 49
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[47], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram50( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 50 OF 1240 ***
    // Wavefunction(s) for diagram number 50
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[46], w_fp[7], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[48] );
    // Amplitude(s) for diagram number 50
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[39], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram51( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 51 OF 1240 ***
    // Wavefunction(s) for diagram number 51
    // (none)
    // Amplitude(s) for diagram number 51
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[39], w_fp[14], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram52( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 52 OF 1240 ***
    // Wavefunction(s) for diagram number 52
    // (none)
    // Amplitude(s) for diagram number 52
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[47], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram53( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 53 OF 1240 ***
    // Wavefunction(s) for diagram number 53
    // (none)
    // Amplitude(s) for diagram number 53
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[42], w_fp[39], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram54( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 54 OF 1240 ***
    // Wavefunction(s) for diagram number 54
    // (none)
    // Amplitude(s) for diagram number 54
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[39], w_fp[9], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram55( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 55 OF 1240 ***
    // Wavefunction(s) for diagram number 55
    // (none)
    // Amplitude(s) for diagram number 55
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram56( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 56 OF 1240 ***
    // Wavefunction(s) for diagram number 56
    // (none)
    // Amplitude(s) for diagram number 56
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[39], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram57( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 57 OF 1240 ***
    // Wavefunction(s) for diagram number 57
    // (none)
    // Amplitude(s) for diagram number 57
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[28], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram58( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 58 OF 1240 ***
    // Wavefunction(s) for diagram number 58
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[6], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[47] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[47], w_fp[4], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[49] );
    // Amplitude(s) for diagram number 58
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[49], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram59( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 59 OF 1240 ***
    // Wavefunction(s) for diagram number 59
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[47], w_fp[5], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[50] );
    // Amplitude(s) for diagram number 59
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[50], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram60( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 60 OF 1240 ***
    // Wavefunction(s) for diagram number 60
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], COUPs[1], 1.0, 0., 0., w_fp[51] );
    // Amplitude(s) for diagram number 60
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[9], w_fp[51], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram61( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 61 OF 1240 ***
    // Wavefunction(s) for diagram number 61
    // (none)
    // Amplitude(s) for diagram number 61
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[50], w_fp[9], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram62( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 62 OF 1240 ***
    // Wavefunction(s) for diagram number 62
    // (none)
    // Amplitude(s) for diagram number 62
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[51], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram63( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 63 OF 1240 ***
    // Wavefunction(s) for diagram number 63
    // (none)
    // Amplitude(s) for diagram number 63
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[49], w_fp[12], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram64( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 64 OF 1240 ***
    // Wavefunction(s) for diagram number 64
    // (none)
    // Amplitude(s) for diagram number 64
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[15], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[17], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram65( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 65 OF 1240 ***
    // Wavefunction(s) for diagram number 65
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[47], w_fp[7], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[52] );
    // Amplitude(s) for diagram number 65
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[52], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram66( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 66 OF 1240 ***
    // Wavefunction(s) for diagram number 66
    // (none)
    // Amplitude(s) for diagram number 66
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[47], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram67( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 67 OF 1240 ***
    // Wavefunction(s) for diagram number 67
    // (none)
    // Amplitude(s) for diagram number 67
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[47], w_fp[12], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram68( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 68 OF 1240 ***
    // Wavefunction(s) for diagram number 68
    // (none)
    // Amplitude(s) for diagram number 68
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[52], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram69( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 69 OF 1240 ***
    // Wavefunction(s) for diagram number 69
    // (none)
    // Amplitude(s) for diagram number 69
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[47], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram70( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 70 OF 1240 ***
    // Wavefunction(s) for diagram number 70
    // (none)
    // Amplitude(s) for diagram number 70
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[47], w_fp[9], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram71( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 71 OF 1240 ***
    // Wavefunction(s) for diagram number 71
    // (none)
    // Amplitude(s) for diagram number 71
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[52], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram72( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 72 OF 1240 ***
    // Wavefunction(s) for diagram number 72
    // (none)
    // Amplitude(s) for diagram number 72
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[47], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram73( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 73 OF 1240 ***
    // Wavefunction(s) for diagram number 73
    // (none)
    // Amplitude(s) for diagram number 73
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[26], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram74( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 74 OF 1240 ***
    // Wavefunction(s) for diagram number 74
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[7], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[52] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[46], w_fp[5], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[7] );
    // Amplitude(s) for diagram number 74
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[52], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram75( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 75 OF 1240 ***
    // Wavefunction(s) for diagram number 75
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[46], w_fp[6], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[53] );
    // Amplitude(s) for diagram number 75
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[53], w_fp[52], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram76( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 76 OF 1240 ***
    // Wavefunction(s) for diagram number 76
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], COUPs[1], 1.0, 0., 0., w_fp[54] );
    // Amplitude(s) for diagram number 76
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[54], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram77( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 77 OF 1240 ***
    // Wavefunction(s) for diagram number 77
    // (none)
    // Amplitude(s) for diagram number 77
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[53], w_fp[2], w_fp[12], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram78( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 78 OF 1240 ***
    // Wavefunction(s) for diagram number 78
    // (none)
    // Amplitude(s) for diagram number 78
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[54], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram79( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 79 OF 1240 ***
    // Wavefunction(s) for diagram number 79
    // (none)
    // Amplitude(s) for diagram number 79
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[2], w_fp[14], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram80( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 80 OF 1240 ***
    // Wavefunction(s) for diagram number 80
    // (none)
    // Amplitude(s) for diagram number 80
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[22], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[23], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram81( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 81 OF 1240 ***
    // Wavefunction(s) for diagram number 81
    // (none)
    // Amplitude(s) for diagram number 81
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[52], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram82( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 82 OF 1240 ***
    // Wavefunction(s) for diagram number 82
    // (none)
    // Amplitude(s) for diagram number 82
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[2], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram83( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 83 OF 1240 ***
    // Wavefunction(s) for diagram number 83
    // (none)
    // Amplitude(s) for diagram number 83
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[25], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram84( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 84 OF 1240 ***
    // Wavefunction(s) for diagram number 84
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[38], w_fp[4], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[25] );
    // Amplitude(s) for diagram number 84
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[25], w_fp[52], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram85( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 85 OF 1240 ***
    // Wavefunction(s) for diagram number 85
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[38], w_fp[6], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[48] );
    // Amplitude(s) for diagram number 85
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[52], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram86( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 86 OF 1240 ***
    // Wavefunction(s) for diagram number 86
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], COUPs[1], 1.0, 0., 0., w_fp[23] );
    // Amplitude(s) for diagram number 86
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[9], w_fp[23], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram87( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 87 OF 1240 ***
    // Wavefunction(s) for diagram number 87
    // (none)
    // Amplitude(s) for diagram number 87
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[2], w_fp[9], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram88( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 88 OF 1240 ***
    // Wavefunction(s) for diagram number 88
    // (none)
    // Amplitude(s) for diagram number 88
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[23], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram89( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 89 OF 1240 ***
    // Wavefunction(s) for diagram number 89
    // (none)
    // Amplitude(s) for diagram number 89
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[25], w_fp[2], w_fp[14], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram90( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 90 OF 1240 ***
    // Wavefunction(s) for diagram number 90
    // (none)
    // Amplitude(s) for diagram number 90
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[18], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[19], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[20], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram91( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 91 OF 1240 ***
    // Wavefunction(s) for diagram number 91
    // (none)
    // Amplitude(s) for diagram number 91
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[52], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram92( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 92 OF 1240 ***
    // Wavefunction(s) for diagram number 92
    // (none)
    // Amplitude(s) for diagram number 92
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[2], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram93( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 93 OF 1240 ***
    // Wavefunction(s) for diagram number 93
    // (none)
    // Amplitude(s) for diagram number 93
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[28], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram94( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 94 OF 1240 ***
    // Wavefunction(s) for diagram number 94
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[41], w_fp[4], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[28] );
    // Amplitude(s) for diagram number 94
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[28], w_fp[52], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram95( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 95 OF 1240 ***
    // Wavefunction(s) for diagram number 95
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[41], w_fp[5], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[40] );
    // Amplitude(s) for diagram number 95
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[52], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram96( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 96 OF 1240 ***
    // Wavefunction(s) for diagram number 96
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], COUPs[1], 1.0, 0., 0., w_fp[20] );
    // Amplitude(s) for diagram number 96
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[9], w_fp[20], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram97( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 97 OF 1240 ***
    // Wavefunction(s) for diagram number 97
    // (none)
    // Amplitude(s) for diagram number 97
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[2], w_fp[9], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram98( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 98 OF 1240 ***
    // Wavefunction(s) for diagram number 98
    // (none)
    // Amplitude(s) for diagram number 98
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[20], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram99( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
             fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
             const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
             const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
             const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
             fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
             fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 99 OF 1240 ***
    // Wavefunction(s) for diagram number 99
    // (none)
    // Amplitude(s) for diagram number 99
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[28], w_fp[2], w_fp[12], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram100( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 100 OF 1240 ***
    // Wavefunction(s) for diagram number 100
    // (none)
    // Amplitude(s) for diagram number 100
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[15], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[17], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram101( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 101 OF 1240 ***
    // Wavefunction(s) for diagram number 101
    // (none)
    // Amplitude(s) for diagram number 101
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[52], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram102( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 102 OF 1240 ***
    // Wavefunction(s) for diagram number 102
    // (none)
    // Amplitude(s) for diagram number 102
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[42], w_fp[2], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram103( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 103 OF 1240 ***
    // Wavefunction(s) for diagram number 103
    // (none)
    // Amplitude(s) for diagram number 103
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[26], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram104( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 104 OF 1240 ***
    // Wavefunction(s) for diagram number 104
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[24], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[26] );
    // Amplitude(s) for diagram number 104
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[26], w_fp[52], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram105( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 105 OF 1240 ***
    // Wavefunction(s) for diagram number 105
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[24], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[42] );
    // Amplitude(s) for diagram number 105
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[52], w_fp[42], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram106( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 106 OF 1240 ***
    // Wavefunction(s) for diagram number 106
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[24], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[17] );
    // Amplitude(s) for diagram number 106
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[17], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram107( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 107 OF 1240 ***
    // Wavefunction(s) for diagram number 107
    // (none)
    // Amplitude(s) for diagram number 107
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[2], w_fp[42], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram108( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 108 OF 1240 ***
    // Wavefunction(s) for diagram number 108
    // (none)
    // Amplitude(s) for diagram number 108
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[17], w_fp[14], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram109( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 109 OF 1240 ***
    // Wavefunction(s) for diagram number 109
    // (none)
    // Amplitude(s) for diagram number 109
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[26], w_fp[2], w_fp[14], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram110( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 110 OF 1240 ***
    // Wavefunction(s) for diagram number 110
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[27], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[14] );
    // Amplitude(s) for diagram number 110
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[52], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram111( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 111 OF 1240 ***
    // Wavefunction(s) for diagram number 111
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[27], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[16] );
    // Amplitude(s) for diagram number 111
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[52], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram112( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 112 OF 1240 ***
    // Wavefunction(s) for diagram number 112
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[27], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[15] );
    // Amplitude(s) for diagram number 112
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[15], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram113( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 113 OF 1240 ***
    // Wavefunction(s) for diagram number 113
    // (none)
    // Amplitude(s) for diagram number 113
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[2], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram114( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 114 OF 1240 ***
    // Wavefunction(s) for diagram number 114
    // (none)
    // Amplitude(s) for diagram number 114
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[15], w_fp[12], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram115( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 115 OF 1240 ***
    // Wavefunction(s) for diagram number 115
    // (none)
    // Amplitude(s) for diagram number 115
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[2], w_fp[12], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram116( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 116 OF 1240 ***
    // Wavefunction(s) for diagram number 116
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[29], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[12] );
    // Amplitude(s) for diagram number 116
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[52], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram117( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 117 OF 1240 ***
    // Wavefunction(s) for diagram number 117
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[4], w_fp[29], COUPs[0], 1.0, 0., 0., w_fp[19] );
    // Amplitude(s) for diagram number 117
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[52], w_fp[19], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram118( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 118 OF 1240 ***
    // Wavefunction(s) for diagram number 118
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[29], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[18] );
    // Amplitude(s) for diagram number 118
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[18], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram119( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 119 OF 1240 ***
    // Wavefunction(s) for diagram number 119
    // (none)
    // Amplitude(s) for diagram number 119
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[2], w_fp[19], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram120( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 120 OF 1240 ***
    // Wavefunction(s) for diagram number 120
    // (none)
    // Amplitude(s) for diagram number 120
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[18], w_fp[9], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram121( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 121 OF 1240 ***
    // Wavefunction(s) for diagram number 121
    // (none)
    // Amplitude(s) for diagram number 121
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[2], w_fp[9], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram122( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 122 OF 1240 ***
    // Wavefunction(s) for diagram number 122
    // (none)
    // Amplitude(s) for diagram number 122
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[52], w_fp[30], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[52], w_fp[31], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[52], w_fp[32], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram123( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 123 OF 1240 ***
    // Wavefunction(s) for diagram number 123
    // (none)
    // Amplitude(s) for diagram number 123
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[2], w_fp[30], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[2], w_fp[31], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[2], w_fp[32], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram124( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 124 OF 1240 ***
    // Wavefunction(s) for diagram number 124
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[0], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[34] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[1], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[52] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[34], w_fp[4], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[9] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[52], w_fp[5], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[22] );
    // Amplitude(s) for diagram number 124
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[22], w_fp[9], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram125( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 125 OF 1240 ***
    // Wavefunction(s) for diagram number 125
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[52], w_fp[6], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[21] );
    // Amplitude(s) for diagram number 125
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[9], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram126( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 126 OF 1240 ***
    // Wavefunction(s) for diagram number 126
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[34], w_fp[5], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[55] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[52], w_fp[4], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[56] );
    // Amplitude(s) for diagram number 126
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[55], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram127( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 127 OF 1240 ***
    // Wavefunction(s) for diagram number 127
    // (none)
    // Amplitude(s) for diagram number 127
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[55], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram128( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 128 OF 1240 ***
    // Wavefunction(s) for diagram number 128
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[34], w_fp[6], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[57] );
    // Amplitude(s) for diagram number 128
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[57], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram129( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 129 OF 1240 ***
    // Wavefunction(s) for diagram number 129
    // (none)
    // Amplitude(s) for diagram number 129
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[22], w_fp[57], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram130( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 130 OF 1240 ***
    // Wavefunction(s) for diagram number 130
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[52], w_fp[34], COUPs[1], 1.0, 0., 0., w_fp[58] );
    // Amplitude(s) for diagram number 130
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[24], w_fp[6], w_fp[58], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram131( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 131 OF 1240 ***
    // Wavefunction(s) for diagram number 131
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[34], w_fp[24], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[59] );
    // Amplitude(s) for diagram number 131
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[59], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram132( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 132 OF 1240 ***
    // Wavefunction(s) for diagram number 132
    // (none)
    // Amplitude(s) for diagram number 132
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[57], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram133( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 133 OF 1240 ***
    // Wavefunction(s) for diagram number 133
    // (none)
    // Amplitude(s) for diagram number 133
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[27], w_fp[5], w_fp[58], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram134( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 134 OF 1240 ***
    // Wavefunction(s) for diagram number 134
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[34], w_fp[27], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[60] );
    // Amplitude(s) for diagram number 134
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[60], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram135( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 135 OF 1240 ***
    // Wavefunction(s) for diagram number 135
    // (none)
    // Amplitude(s) for diagram number 135
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[55], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram136( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 136 OF 1240 ***
    // Wavefunction(s) for diagram number 136
    // (none)
    // Amplitude(s) for diagram number 136
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[4], w_fp[29], w_fp[58], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram137( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 137 OF 1240 ***
    // Wavefunction(s) for diagram number 137
    // (none)
    // Amplitude(s) for diagram number 137
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[9], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram138( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 138 OF 1240 ***
    // Wavefunction(s) for diagram number 138
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[34], w_fp[29], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[58] );
    // Amplitude(s) for diagram number 138
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[58], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram139( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 139 OF 1240 ***
    // Wavefunction(s) for diagram number 139
    // (none)
    // Amplitude(s) for diagram number 139
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[34], w_fp[30], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[34], w_fp[31], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[34], w_fp[32], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram140( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 140 OF 1240 ***
    // Wavefunction(s) for diagram number 140
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[61] );
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[34], COUPs[1], 1.0, 0., 0., w_fp[62] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[63] );
    // Amplitude(s) for diagram number 140
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[63], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram141( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 141 OF 1240 ***
    // Wavefunction(s) for diagram number 141
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[61], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[64] );
    // Amplitude(s) for diagram number 141
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[64], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram142( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 142 OF 1240 ***
    // Wavefunction(s) for diagram number 142
    // (none)
    // Amplitude(s) for diagram number 142
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[6], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[6], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[6], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram143( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 143 OF 1240 ***
    // Wavefunction(s) for diagram number 143
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[61], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[65] );
    // Amplitude(s) for diagram number 143
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[55], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram144( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 144 OF 1240 ***
    // Wavefunction(s) for diagram number 144
    // (none)
    // Amplitude(s) for diagram number 144
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[55], w_fp[64], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram145( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 145 OF 1240 ***
    // Wavefunction(s) for diagram number 145
    // (none)
    // Amplitude(s) for diagram number 145
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[57], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram146( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 146 OF 1240 ***
    // Wavefunction(s) for diagram number 146
    // (none)
    // Amplitude(s) for diagram number 146
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[57], w_fp[63], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram147( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 147 OF 1240 ***
    // Wavefunction(s) for diagram number 147
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[34], w_fp[61], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[66] );
    // Amplitude(s) for diagram number 147
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[66], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram148( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 148 OF 1240 ***
    // Wavefunction(s) for diagram number 148
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[38], w_fp[34], COUPs[1], 1.0, 0., 0., w_fp[67] );
    // Amplitude(s) for diagram number 148
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[6], w_fp[67], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram149( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 149 OF 1240 ***
    // Wavefunction(s) for diagram number 149
    // (none)
    // Amplitude(s) for diagram number 149
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[57], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram150( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 150 OF 1240 ***
    // Wavefunction(s) for diagram number 150
    // (none)
    // Amplitude(s) for diagram number 150
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[66], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram151( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 151 OF 1240 ***
    // Wavefunction(s) for diagram number 151
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[41], w_fp[34], COUPs[1], 1.0, 0., 0., w_fp[68] );
    // Amplitude(s) for diagram number 151
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[68], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram152( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 152 OF 1240 ***
    // Wavefunction(s) for diagram number 152
    // (none)
    // Amplitude(s) for diagram number 152
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[55], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram153( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 153 OF 1240 ***
    // Wavefunction(s) for diagram number 153
    // (none)
    // Amplitude(s) for diagram number 153
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[66], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram154( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 154 OF 1240 ***
    // Wavefunction(s) for diagram number 154
    // (none)
    // Amplitude(s) for diagram number 154
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[29], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram155( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 155 OF 1240 ***
    // Wavefunction(s) for diagram number 155
    // (none)
    // Amplitude(s) for diagram number 155
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[58], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram156( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 156 OF 1240 ***
    // Wavefunction(s) for diagram number 156
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[66] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[69] );
    // Amplitude(s) for diagram number 156
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[69], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram157( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 157 OF 1240 ***
    // Wavefunction(s) for diagram number 157
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[66], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[70] );
    // Amplitude(s) for diagram number 157
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[70], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram158( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 158 OF 1240 ***
    // Wavefunction(s) for diagram number 158
    // (none)
    // Amplitude(s) for diagram number 158
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[6], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[6], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[6], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram159( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 159 OF 1240 ***
    // Wavefunction(s) for diagram number 159
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[66], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[71] );
    // Amplitude(s) for diagram number 159
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[9], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram160( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 160 OF 1240 ***
    // Wavefunction(s) for diagram number 160
    // (none)
    // Amplitude(s) for diagram number 160
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[9], w_fp[70], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram161( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 161 OF 1240 ***
    // Wavefunction(s) for diagram number 161
    // (none)
    // Amplitude(s) for diagram number 161
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[57], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram162( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 162 OF 1240 ***
    // Wavefunction(s) for diagram number 162
    // (none)
    // Amplitude(s) for diagram number 162
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[57], w_fp[69], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram163( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 163 OF 1240 ***
    // Wavefunction(s) for diagram number 163
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[34], w_fp[66], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[72] );
    // Amplitude(s) for diagram number 163
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[72], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram164( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 164 OF 1240 ***
    // Wavefunction(s) for diagram number 164
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[46], w_fp[34], COUPs[1], 1.0, 0., 0., w_fp[73] );
    // Amplitude(s) for diagram number 164
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[6], w_fp[73], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram165( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 165 OF 1240 ***
    // Wavefunction(s) for diagram number 165
    // (none)
    // Amplitude(s) for diagram number 165
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[57], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram166( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 166 OF 1240 ***
    // Wavefunction(s) for diagram number 166
    // (none)
    // Amplitude(s) for diagram number 166
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[72], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram167( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 167 OF 1240 ***
    // Wavefunction(s) for diagram number 167
    // (none)
    // Amplitude(s) for diagram number 167
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[68], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram168( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 168 OF 1240 ***
    // Wavefunction(s) for diagram number 168
    // (none)
    // Amplitude(s) for diagram number 168
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[9], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram169( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 169 OF 1240 ***
    // Wavefunction(s) for diagram number 169
    // (none)
    // Amplitude(s) for diagram number 169
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[72], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram170( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 170 OF 1240 ***
    // Wavefunction(s) for diagram number 170
    // (none)
    // Amplitude(s) for diagram number 170
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[27], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram171( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 171 OF 1240 ***
    // Wavefunction(s) for diagram number 171
    // (none)
    // Amplitude(s) for diagram number 171
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[60], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram172( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 172 OF 1240 ***
    // Wavefunction(s) for diagram number 172
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[72] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[74] );
    // Amplitude(s) for diagram number 172
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[74], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram173( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 173 OF 1240 ***
    // Wavefunction(s) for diagram number 173
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[72], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[75] );
    // Amplitude(s) for diagram number 173
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[75], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram174( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 174 OF 1240 ***
    // Wavefunction(s) for diagram number 174
    // (none)
    // Amplitude(s) for diagram number 174
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[5], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[5], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[5], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram175( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 175 OF 1240 ***
    // Wavefunction(s) for diagram number 175
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[72], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[76] );
    // Amplitude(s) for diagram number 175
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[76], w_fp[9], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram176( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 176 OF 1240 ***
    // Wavefunction(s) for diagram number 176
    // (none)
    // Amplitude(s) for diagram number 176
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[9], w_fp[75], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram177( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 177 OF 1240 ***
    // Wavefunction(s) for diagram number 177
    // (none)
    // Amplitude(s) for diagram number 177
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[76], w_fp[55], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram178( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 178 OF 1240 ***
    // Wavefunction(s) for diagram number 178
    // (none)
    // Amplitude(s) for diagram number 178
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[55], w_fp[74], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram179( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 179 OF 1240 ***
    // Wavefunction(s) for diagram number 179
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[34], w_fp[72], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[77] );
    // Amplitude(s) for diagram number 179
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[77], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram180( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 180 OF 1240 ***
    // Wavefunction(s) for diagram number 180
    // (none)
    // Amplitude(s) for diagram number 180
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[5], w_fp[73], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram181( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 181 OF 1240 ***
    // Wavefunction(s) for diagram number 181
    // (none)
    // Amplitude(s) for diagram number 181
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[55], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram182( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 182 OF 1240 ***
    // Wavefunction(s) for diagram number 182
    // (none)
    // Amplitude(s) for diagram number 182
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[77], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram183( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 183 OF 1240 ***
    // Wavefunction(s) for diagram number 183
    // (none)
    // Amplitude(s) for diagram number 183
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[67], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram184( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 184 OF 1240 ***
    // Wavefunction(s) for diagram number 184
    // (none)
    // Amplitude(s) for diagram number 184
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[9], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram185( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 185 OF 1240 ***
    // Wavefunction(s) for diagram number 185
    // (none)
    // Amplitude(s) for diagram number 185
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram186( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 186 OF 1240 ***
    // Wavefunction(s) for diagram number 186
    // (none)
    // Amplitude(s) for diagram number 186
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[24], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram187( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 187 OF 1240 ***
    // Wavefunction(s) for diagram number 187
    // (none)
    // Amplitude(s) for diagram number 187
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[59], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram188( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 188 OF 1240 ***
    // Wavefunction(s) for diagram number 188
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[34], w_fp[1], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[77] );
    // Amplitude(s) for diagram number 188
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[77], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram189( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 189 OF 1240 ***
    // Wavefunction(s) for diagram number 189
    // (none)
    // Amplitude(s) for diagram number 189
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[53], w_fp[77], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram190( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 190 OF 1240 ***
    // Wavefunction(s) for diagram number 190
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[46], w_fp[1], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[78] );
    // Amplitude(s) for diagram number 190
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[78], w_fp[55], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram191( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 191 OF 1240 ***
    // Wavefunction(s) for diagram number 191
    // (none)
    // Amplitude(s) for diagram number 191
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[53], w_fp[55], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram192( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 192 OF 1240 ***
    // Wavefunction(s) for diagram number 192
    // (none)
    // Amplitude(s) for diagram number 192
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[78], w_fp[57], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram193( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 193 OF 1240 ***
    // Wavefunction(s) for diagram number 193
    // (none)
    // Amplitude(s) for diagram number 193
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[57], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram194( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 194 OF 1240 ***
    // Wavefunction(s) for diagram number 194
    // (none)
    // Amplitude(s) for diagram number 194
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[77], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram195( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 195 OF 1240 ***
    // Wavefunction(s) for diagram number 195
    // (none)
    // Amplitude(s) for diagram number 195
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[29], w_fp[73], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram196( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 196 OF 1240 ***
    // Wavefunction(s) for diagram number 196
    // (none)
    // Amplitude(s) for diagram number 196
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[58], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram197( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 197 OF 1240 ***
    // Wavefunction(s) for diagram number 197
    // (none)
    // Amplitude(s) for diagram number 197
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[25], w_fp[77], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram198( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 198 OF 1240 ***
    // Wavefunction(s) for diagram number 198
    // (none)
    // Amplitude(s) for diagram number 198
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[77], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram199( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 199 OF 1240 ***
    // Wavefunction(s) for diagram number 199
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[38], w_fp[1], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[58] );
    // Amplitude(s) for diagram number 199
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[58], w_fp[9], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram200( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 200 OF 1240 ***
    // Wavefunction(s) for diagram number 200
    // (none)
    // Amplitude(s) for diagram number 200
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[9], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram201( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 201 OF 1240 ***
    // Wavefunction(s) for diagram number 201
    // (none)
    // Amplitude(s) for diagram number 201
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[58], w_fp[57], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram202( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 202 OF 1240 ***
    // Wavefunction(s) for diagram number 202
    // (none)
    // Amplitude(s) for diagram number 202
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[25], w_fp[57], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram203( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 203 OF 1240 ***
    // Wavefunction(s) for diagram number 203
    // (none)
    // Amplitude(s) for diagram number 203
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[77], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram204( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 204 OF 1240 ***
    // Wavefunction(s) for diagram number 204
    // (none)
    // Amplitude(s) for diagram number 204
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[67], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram205( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 205 OF 1240 ***
    // Wavefunction(s) for diagram number 205
    // (none)
    // Amplitude(s) for diagram number 205
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[60], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram206( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 206 OF 1240 ***
    // Wavefunction(s) for diagram number 206
    // (none)
    // Amplitude(s) for diagram number 206
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[28], w_fp[77], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram207( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 207 OF 1240 ***
    // Wavefunction(s) for diagram number 207
    // (none)
    // Amplitude(s) for diagram number 207
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[77], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram208( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 208 OF 1240 ***
    // Wavefunction(s) for diagram number 208
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[41], w_fp[1], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[60] );
    // Amplitude(s) for diagram number 208
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[9], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram209( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 209 OF 1240 ***
    // Wavefunction(s) for diagram number 209
    // (none)
    // Amplitude(s) for diagram number 209
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[9], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram210( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 210 OF 1240 ***
    // Wavefunction(s) for diagram number 210
    // (none)
    // Amplitude(s) for diagram number 210
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[55], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram211( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 211 OF 1240 ***
    // Wavefunction(s) for diagram number 211
    // (none)
    // Amplitude(s) for diagram number 211
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[28], w_fp[55], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram212( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 212 OF 1240 ***
    // Wavefunction(s) for diagram number 212
    // (none)
    // Amplitude(s) for diagram number 212
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[77], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram213( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 213 OF 1240 ***
    // Wavefunction(s) for diagram number 213
    // (none)
    // Amplitude(s) for diagram number 213
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[68], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram214( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 214 OF 1240 ***
    // Wavefunction(s) for diagram number 214
    // (none)
    // Amplitude(s) for diagram number 214
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[59], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram215( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 215 OF 1240 ***
    // Wavefunction(s) for diagram number 215
    // (none)
    // Amplitude(s) for diagram number 215
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[26], w_fp[77], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram216( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 216 OF 1240 ***
    // Wavefunction(s) for diagram number 216
    // (none)
    // Amplitude(s) for diagram number 216
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[42], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram217( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 217 OF 1240 ***
    // Wavefunction(s) for diagram number 217
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], COUPs[0], 1.0, 0., 0., w_fp[59] );
    // Amplitude(s) for diagram number 217
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[59], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram218( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 218 OF 1240 ***
    // Wavefunction(s) for diagram number 218
    // (none)
    // Amplitude(s) for diagram number 218
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[1], w_fp[42], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram219( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 219 OF 1240 ***
    // Wavefunction(s) for diagram number 219
    // (none)
    // Amplitude(s) for diagram number 219
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[6], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[6], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[6], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram220( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 220 OF 1240 ***
    // Wavefunction(s) for diagram number 220
    // (none)
    // Amplitude(s) for diagram number 220
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[57], w_fp[59], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram221( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 221 OF 1240 ***
    // Wavefunction(s) for diagram number 221
    // (none)
    // Amplitude(s) for diagram number 221
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[26], w_fp[57], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram222( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 222 OF 1240 ***
    // Wavefunction(s) for diagram number 222
    // (none)
    // Amplitude(s) for diagram number 222
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[77], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram223( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 223 OF 1240 ***
    // Wavefunction(s) for diagram number 223
    // (none)
    // Amplitude(s) for diagram number 223
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram224( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 224 OF 1240 ***
    // Wavefunction(s) for diagram number 224
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], COUPs[0], 1.0, 0., 0., w_fp[68] );
    // Amplitude(s) for diagram number 224
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[68], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram225( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 225 OF 1240 ***
    // Wavefunction(s) for diagram number 225
    // (none)
    // Amplitude(s) for diagram number 225
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[1], w_fp[16], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram226( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 226 OF 1240 ***
    // Wavefunction(s) for diagram number 226
    // (none)
    // Amplitude(s) for diagram number 226
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[5], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[5], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[5], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram227( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 227 OF 1240 ***
    // Wavefunction(s) for diagram number 227
    // (none)
    // Amplitude(s) for diagram number 227
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[55], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram228( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 228 OF 1240 ***
    // Wavefunction(s) for diagram number 228
    // (none)
    // Amplitude(s) for diagram number 228
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[55], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram229( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 229 OF 1240 ***
    // Wavefunction(s) for diagram number 229
    // (none)
    // Amplitude(s) for diagram number 229
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[77], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram230( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 230 OF 1240 ***
    // Wavefunction(s) for diagram number 230
    // (none)
    // Amplitude(s) for diagram number 230
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[19], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram231( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 231 OF 1240 ***
    // Wavefunction(s) for diagram number 231
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[29], COUPs[0], 1.0, 0., 0., w_fp[67] );
    // Amplitude(s) for diagram number 231
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[67], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram232( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 232 OF 1240 ***
    // Wavefunction(s) for diagram number 232
    // (none)
    // Amplitude(s) for diagram number 232
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[1], w_fp[19], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram233( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 233 OF 1240 ***
    // Wavefunction(s) for diagram number 233
    // (none)
    // Amplitude(s) for diagram number 233
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[29], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[29], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[29], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram234( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 234 OF 1240 ***
    // Wavefunction(s) for diagram number 234
    // (none)
    // Amplitude(s) for diagram number 234
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[9], w_fp[67], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram235( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 235 OF 1240 ***
    // Wavefunction(s) for diagram number 235
    // (none)
    // Amplitude(s) for diagram number 235
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[9], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram236( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 236 OF 1240 ***
    // Wavefunction(s) for diagram number 236
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[73] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[79] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[80] );
    // Amplitude(s) for diagram number 236
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[73], w_fp[6], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[79], w_fp[6], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[80], w_fp[6], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram237( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 237 OF 1240 ***
    // Wavefunction(s) for diagram number 237
    // (none)
    // Amplitude(s) for diagram number 237
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[57], w_fp[73], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[57], w_fp[79], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[57], w_fp[80], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram238( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 238 OF 1240 ***
    // Wavefunction(s) for diagram number 238
    // (none)
    // Amplitude(s) for diagram number 238
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[34], w_fp[73], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[34], w_fp[79], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[34], w_fp[80], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram239( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 239 OF 1240 ***
    // Wavefunction(s) for diagram number 239
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[57] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[81] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[82] );
    // Amplitude(s) for diagram number 239
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[57], w_fp[5], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[81], w_fp[5], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[82], w_fp[5], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram240( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 240 OF 1240 ***
    // Wavefunction(s) for diagram number 240
    // (none)
    // Amplitude(s) for diagram number 240
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[55], w_fp[57], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[55], w_fp[81], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[55], w_fp[82], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram241( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 241 OF 1240 ***
    // Wavefunction(s) for diagram number 241
    // (none)
    // Amplitude(s) for diagram number 241
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[34], w_fp[57], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[34], w_fp[81], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[34], w_fp[82], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram242( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 242 OF 1240 ***
    // Wavefunction(s) for diagram number 242
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[55] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[83] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[84] );
    // Amplitude(s) for diagram number 242
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[55], w_fp[4], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[83], w_fp[4], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[84], w_fp[4], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram243( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 243 OF 1240 ***
    // Wavefunction(s) for diagram number 243
    // (none)
    // Amplitude(s) for diagram number 243
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[9], w_fp[55], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[9], w_fp[83], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[9], w_fp[84], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram244( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 244 OF 1240 ***
    // Wavefunction(s) for diagram number 244
    // (none)
    // Amplitude(s) for diagram number 244
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[34], w_fp[55], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[34], w_fp[83], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[34], w_fp[84], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram245( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 245 OF 1240 ***
    // Wavefunction(s) for diagram number 245
    // (none)
    // Amplitude(s) for diagram number 245
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[30], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[31], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[32], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram246( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 246 OF 1240 ***
    // Wavefunction(s) for diagram number 246
    // (none)
    // Amplitude(s) for diagram number 246
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[30], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[31], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[32], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram247( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 247 OF 1240 ***
    // Wavefunction(s) for diagram number 247
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[0], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[62] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[1], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[77] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[4], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[34] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[77], w_fp[5], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[9] );
    // Amplitude(s) for diagram number 247
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[9], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram248( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 248 OF 1240 ***
    // Wavefunction(s) for diagram number 248
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[77], w_fp[6], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[85] );
    // Amplitude(s) for diagram number 248
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[85], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram249( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 249 OF 1240 ***
    // Wavefunction(s) for diagram number 249
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[5], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[86] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[77], w_fp[4], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[87] );
    // Amplitude(s) for diagram number 249
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[87], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram250( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 250 OF 1240 ***
    // Wavefunction(s) for diagram number 250
    // (none)
    // Amplitude(s) for diagram number 250
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[85], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram251( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 251 OF 1240 ***
    // Wavefunction(s) for diagram number 251
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[6], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[88] );
    // Amplitude(s) for diagram number 251
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[87], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram252( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 252 OF 1240 ***
    // Wavefunction(s) for diagram number 252
    // (none)
    // Amplitude(s) for diagram number 252
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[9], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram253( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 253 OF 1240 ***
    // Wavefunction(s) for diagram number 253
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[77], COUPs[1], 1.0, 0., 0., w_fp[89] );
    // Amplitude(s) for diagram number 253
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[24], w_fp[6], w_fp[89], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram254( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 254 OF 1240 ***
    // Wavefunction(s) for diagram number 254
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[24], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[90] );
    // Amplitude(s) for diagram number 254
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[77], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram255( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 255 OF 1240 ***
    // Wavefunction(s) for diagram number 255
    // (none)
    // Amplitude(s) for diagram number 255
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[77], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram256( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 256 OF 1240 ***
    // Wavefunction(s) for diagram number 256
    // (none)
    // Amplitude(s) for diagram number 256
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[27], w_fp[5], w_fp[89], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram257( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 257 OF 1240 ***
    // Wavefunction(s) for diagram number 257
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[27], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[91] );
    // Amplitude(s) for diagram number 257
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[91], w_fp[77], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram258( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 258 OF 1240 ***
    // Wavefunction(s) for diagram number 258
    // (none)
    // Amplitude(s) for diagram number 258
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[77], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram259( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 259 OF 1240 ***
    // Wavefunction(s) for diagram number 259
    // (none)
    // Amplitude(s) for diagram number 259
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[4], w_fp[29], w_fp[89], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram260( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 260 OF 1240 ***
    // Wavefunction(s) for diagram number 260
    // (none)
    // Amplitude(s) for diagram number 260
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[77], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram261( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 261 OF 1240 ***
    // Wavefunction(s) for diagram number 261
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[29], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[89] );
    // Amplitude(s) for diagram number 261
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[89], w_fp[77], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram262( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 262 OF 1240 ***
    // Wavefunction(s) for diagram number 262
    // (none)
    // Amplitude(s) for diagram number 262
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[77], w_fp[30], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[77], w_fp[31], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[77], w_fp[32], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram263( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 263 OF 1240 ***
    // Wavefunction(s) for diagram number 263
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[2], COUPs[1], 1.0, 0., 0., w_fp[92] );
    // Amplitude(s) for diagram number 263
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[63], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram264( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 264 OF 1240 ***
    // Wavefunction(s) for diagram number 264
    // (none)
    // Amplitude(s) for diagram number 264
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[64], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram265( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 265 OF 1240 ***
    // Wavefunction(s) for diagram number 265
    // (none)
    // Amplitude(s) for diagram number 265
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[6], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[6], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[6], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram266( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 266 OF 1240 ***
    // Wavefunction(s) for diagram number 266
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[61], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[93] );
    // Amplitude(s) for diagram number 266
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[93], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram267( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 267 OF 1240 ***
    // Wavefunction(s) for diagram number 267
    // (none)
    // Amplitude(s) for diagram number 267
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[2], w_fp[64], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram268( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 268 OF 1240 ***
    // Wavefunction(s) for diagram number 268
    // (none)
    // Amplitude(s) for diagram number 268
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[93], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram269( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 269 OF 1240 ***
    // Wavefunction(s) for diagram number 269
    // (none)
    // Amplitude(s) for diagram number 269
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[2], w_fp[63], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram270( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 270 OF 1240 ***
    // Wavefunction(s) for diagram number 270
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[61], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[94] );
    // Amplitude(s) for diagram number 270
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[94], w_fp[39], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram271( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 271 OF 1240 ***
    // Wavefunction(s) for diagram number 271
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[39], COUPs[1], 1.0, 0., 0., w_fp[95] );
    // Amplitude(s) for diagram number 271
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[6], w_fp[95], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram272( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 272 OF 1240 ***
    // Wavefunction(s) for diagram number 272
    // (none)
    // Amplitude(s) for diagram number 272
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[39], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram273( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 273 OF 1240 ***
    // Wavefunction(s) for diagram number 273
    // (none)
    // Amplitude(s) for diagram number 273
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[94], w_fp[47], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram274( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 274 OF 1240 ***
    // Wavefunction(s) for diagram number 274
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[47], COUPs[1], 1.0, 0., 0., w_fp[96] );
    // Amplitude(s) for diagram number 274
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[96], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram275( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 275 OF 1240 ***
    // Wavefunction(s) for diagram number 275
    // (none)
    // Amplitude(s) for diagram number 275
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[47], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram276( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 276 OF 1240 ***
    // Wavefunction(s) for diagram number 276
    // (none)
    // Amplitude(s) for diagram number 276
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[94], w_fp[2], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram277( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 277 OF 1240 ***
    // Wavefunction(s) for diagram number 277
    // (none)
    // Amplitude(s) for diagram number 277
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[29], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram278( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 278 OF 1240 ***
    // Wavefunction(s) for diagram number 278
    // (none)
    // Amplitude(s) for diagram number 278
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[89], w_fp[2], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram279( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 279 OF 1240 ***
    // Wavefunction(s) for diagram number 279
    // (none)
    // Amplitude(s) for diagram number 279
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[69], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram280( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 280 OF 1240 ***
    // Wavefunction(s) for diagram number 280
    // (none)
    // Amplitude(s) for diagram number 280
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[70], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram281( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 281 OF 1240 ***
    // Wavefunction(s) for diagram number 281
    // (none)
    // Amplitude(s) for diagram number 281
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[6], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[6], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[6], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram282( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 282 OF 1240 ***
    // Wavefunction(s) for diagram number 282
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[66], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[94] );
    // Amplitude(s) for diagram number 282
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[94], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram283( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 283 OF 1240 ***
    // Wavefunction(s) for diagram number 283
    // (none)
    // Amplitude(s) for diagram number 283
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[2], w_fp[70], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram284( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 284 OF 1240 ***
    // Wavefunction(s) for diagram number 284
    // (none)
    // Amplitude(s) for diagram number 284
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[94], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram285( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 285 OF 1240 ***
    // Wavefunction(s) for diagram number 285
    // (none)
    // Amplitude(s) for diagram number 285
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[2], w_fp[69], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram286( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 286 OF 1240 ***
    // Wavefunction(s) for diagram number 286
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[66], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[97] );
    // Amplitude(s) for diagram number 286
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[97], w_fp[33], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram287( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 287 OF 1240 ***
    // Wavefunction(s) for diagram number 287
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[33], COUPs[1], 1.0, 0., 0., w_fp[98] );
    // Amplitude(s) for diagram number 287
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[6], w_fp[98], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram288( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 288 OF 1240 ***
    // Wavefunction(s) for diagram number 288
    // (none)
    // Amplitude(s) for diagram number 288
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[33], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram289( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 289 OF 1240 ***
    // Wavefunction(s) for diagram number 289
    // (none)
    // Amplitude(s) for diagram number 289
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[97], w_fp[47], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram290( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 290 OF 1240 ***
    // Wavefunction(s) for diagram number 290
    // (none)
    // Amplitude(s) for diagram number 290
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[96], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram291( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 291 OF 1240 ***
    // Wavefunction(s) for diagram number 291
    // (none)
    // Amplitude(s) for diagram number 291
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[47], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram292( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 292 OF 1240 ***
    // Wavefunction(s) for diagram number 292
    // (none)
    // Amplitude(s) for diagram number 292
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[97], w_fp[2], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram293( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 293 OF 1240 ***
    // Wavefunction(s) for diagram number 293
    // (none)
    // Amplitude(s) for diagram number 293
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[27], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram294( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 294 OF 1240 ***
    // Wavefunction(s) for diagram number 294
    // (none)
    // Amplitude(s) for diagram number 294
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[91], w_fp[2], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram295( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 295 OF 1240 ***
    // Wavefunction(s) for diagram number 295
    // (none)
    // Amplitude(s) for diagram number 295
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[74], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram296( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 296 OF 1240 ***
    // Wavefunction(s) for diagram number 296
    // (none)
    // Amplitude(s) for diagram number 296
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[75], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram297( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 297 OF 1240 ***
    // Wavefunction(s) for diagram number 297
    // (none)
    // Amplitude(s) for diagram number 297
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[5], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[5], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[5], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram298( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 298 OF 1240 ***
    // Wavefunction(s) for diagram number 298
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[72], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[97] );
    // Amplitude(s) for diagram number 298
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[97], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram299( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 299 OF 1240 ***
    // Wavefunction(s) for diagram number 299
    // (none)
    // Amplitude(s) for diagram number 299
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[2], w_fp[75], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram300( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 300 OF 1240 ***
    // Wavefunction(s) for diagram number 300
    // (none)
    // Amplitude(s) for diagram number 300
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[97], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram301( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 301 OF 1240 ***
    // Wavefunction(s) for diagram number 301
    // (none)
    // Amplitude(s) for diagram number 301
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[2], w_fp[74], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram302( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 302 OF 1240 ***
    // Wavefunction(s) for diagram number 302
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[72], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[99] );
    // Amplitude(s) for diagram number 302
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[33], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram303( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 303 OF 1240 ***
    // Wavefunction(s) for diagram number 303
    // (none)
    // Amplitude(s) for diagram number 303
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[5], w_fp[98], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram304( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 304 OF 1240 ***
    // Wavefunction(s) for diagram number 304
    // (none)
    // Amplitude(s) for diagram number 304
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[33], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram305( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 305 OF 1240 ***
    // Wavefunction(s) for diagram number 305
    // (none)
    // Amplitude(s) for diagram number 305
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[39], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram306( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 306 OF 1240 ***
    // Wavefunction(s) for diagram number 306
    // (none)
    // Amplitude(s) for diagram number 306
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[95], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram307( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 307 OF 1240 ***
    // Wavefunction(s) for diagram number 307
    // (none)
    // Amplitude(s) for diagram number 307
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[39], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram308( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 308 OF 1240 ***
    // Wavefunction(s) for diagram number 308
    // (none)
    // Amplitude(s) for diagram number 308
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram309( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 309 OF 1240 ***
    // Wavefunction(s) for diagram number 309
    // (none)
    // Amplitude(s) for diagram number 309
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[24], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram310( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 310 OF 1240 ***
    // Wavefunction(s) for diagram number 310
    // (none)
    // Amplitude(s) for diagram number 310
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[2], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram311( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 311 OF 1240 ***
    // Wavefunction(s) for diagram number 311
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[62], w_fp[1], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[99] );
    // Amplitude(s) for diagram number 311
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[35], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram312( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 312 OF 1240 ***
    // Wavefunction(s) for diagram number 312
    // (none)
    // Amplitude(s) for diagram number 312
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[36], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram313( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 313 OF 1240 ***
    // Wavefunction(s) for diagram number 313
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[33], w_fp[1], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[100] );
    // Amplitude(s) for diagram number 313
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[100], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram314( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 314 OF 1240 ***
    // Wavefunction(s) for diagram number 314
    // (none)
    // Amplitude(s) for diagram number 314
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[36], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram315( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 315 OF 1240 ***
    // Wavefunction(s) for diagram number 315
    // (none)
    // Amplitude(s) for diagram number 315
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[100], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram316( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 316 OF 1240 ***
    // Wavefunction(s) for diagram number 316
    // (none)
    // Amplitude(s) for diagram number 316
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[35], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram317( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 317 OF 1240 ***
    // Wavefunction(s) for diagram number 317
    // (none)
    // Amplitude(s) for diagram number 317
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[33], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram318( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 318 OF 1240 ***
    // Wavefunction(s) for diagram number 318
    // (none)
    // Amplitude(s) for diagram number 318
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[29], w_fp[98], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram319( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 319 OF 1240 ***
    // Wavefunction(s) for diagram number 319
    // (none)
    // Amplitude(s) for diagram number 319
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[89], w_fp[33], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram320( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 320 OF 1240 ***
    // Wavefunction(s) for diagram number 320
    // (none)
    // Amplitude(s) for diagram number 320
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[43], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram321( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 321 OF 1240 ***
    // Wavefunction(s) for diagram number 321
    // (none)
    // Amplitude(s) for diagram number 321
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[44], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram322( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 322 OF 1240 ***
    // Wavefunction(s) for diagram number 322
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[39], w_fp[1], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[89] );
    // Amplitude(s) for diagram number 322
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[89], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram323( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 323 OF 1240 ***
    // Wavefunction(s) for diagram number 323
    // (none)
    // Amplitude(s) for diagram number 323
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[44], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram324( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 324 OF 1240 ***
    // Wavefunction(s) for diagram number 324
    // (none)
    // Amplitude(s) for diagram number 324
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[89], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram325( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 325 OF 1240 ***
    // Wavefunction(s) for diagram number 325
    // (none)
    // Amplitude(s) for diagram number 325
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[43], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram326( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 326 OF 1240 ***
    // Wavefunction(s) for diagram number 326
    // (none)
    // Amplitude(s) for diagram number 326
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[39], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram327( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 327 OF 1240 ***
    // Wavefunction(s) for diagram number 327
    // (none)
    // Amplitude(s) for diagram number 327
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[95], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram328( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 328 OF 1240 ***
    // Wavefunction(s) for diagram number 328
    // (none)
    // Amplitude(s) for diagram number 328
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[91], w_fp[39], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram329( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 329 OF 1240 ***
    // Wavefunction(s) for diagram number 329
    // (none)
    // Amplitude(s) for diagram number 329
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[49], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram330( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 330 OF 1240 ***
    // Wavefunction(s) for diagram number 330
    // (none)
    // Amplitude(s) for diagram number 330
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[50], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram331( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 331 OF 1240 ***
    // Wavefunction(s) for diagram number 331
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[47], w_fp[1], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[91] );
    // Amplitude(s) for diagram number 331
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[91], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram332( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 332 OF 1240 ***
    // Wavefunction(s) for diagram number 332
    // (none)
    // Amplitude(s) for diagram number 332
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[50], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram333( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 333 OF 1240 ***
    // Wavefunction(s) for diagram number 333
    // (none)
    // Amplitude(s) for diagram number 333
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[91], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram334( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 334 OF 1240 ***
    // Wavefunction(s) for diagram number 334
    // (none)
    // Amplitude(s) for diagram number 334
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[49], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram335( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 335 OF 1240 ***
    // Wavefunction(s) for diagram number 335
    // (none)
    // Amplitude(s) for diagram number 335
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[47], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram336( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 336 OF 1240 ***
    // Wavefunction(s) for diagram number 336
    // (none)
    // Amplitude(s) for diagram number 336
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[96], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram337( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 337 OF 1240 ***
    // Wavefunction(s) for diagram number 337
    // (none)
    // Amplitude(s) for diagram number 337
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[47], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram338( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 338 OF 1240 ***
    // Wavefunction(s) for diagram number 338
    // (none)
    // Amplitude(s) for diagram number 338
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[17], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram339( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 339 OF 1240 ***
    // Wavefunction(s) for diagram number 339
    // (none)
    // Amplitude(s) for diagram number 339
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[42], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram340( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 340 OF 1240 ***
    // Wavefunction(s) for diagram number 340
    // (none)
    // Amplitude(s) for diagram number 340
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[59], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram341( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 341 OF 1240 ***
    // Wavefunction(s) for diagram number 341
    // (none)
    // Amplitude(s) for diagram number 341
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[42], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram342( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 342 OF 1240 ***
    // Wavefunction(s) for diagram number 342
    // (none)
    // Amplitude(s) for diagram number 342
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[6], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[6], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[6], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram343( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 343 OF 1240 ***
    // Wavefunction(s) for diagram number 343
    // (none)
    // Amplitude(s) for diagram number 343
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[2], w_fp[59], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram344( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 344 OF 1240 ***
    // Wavefunction(s) for diagram number 344
    // (none)
    // Amplitude(s) for diagram number 344
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[17], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram345( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 345 OF 1240 ***
    // Wavefunction(s) for diagram number 345
    // (none)
    // Amplitude(s) for diagram number 345
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[15], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram346( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 346 OF 1240 ***
    // Wavefunction(s) for diagram number 346
    // (none)
    // Amplitude(s) for diagram number 346
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram347( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 347 OF 1240 ***
    // Wavefunction(s) for diagram number 347
    // (none)
    // Amplitude(s) for diagram number 347
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[68], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram348( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 348 OF 1240 ***
    // Wavefunction(s) for diagram number 348
    // (none)
    // Amplitude(s) for diagram number 348
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[16], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram349( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 349 OF 1240 ***
    // Wavefunction(s) for diagram number 349
    // (none)
    // Amplitude(s) for diagram number 349
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[5], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[5], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[5], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram350( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 350 OF 1240 ***
    // Wavefunction(s) for diagram number 350
    // (none)
    // Amplitude(s) for diagram number 350
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[2], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram351( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 351 OF 1240 ***
    // Wavefunction(s) for diagram number 351
    // (none)
    // Amplitude(s) for diagram number 351
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[15], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram352( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 352 OF 1240 ***
    // Wavefunction(s) for diagram number 352
    // (none)
    // Amplitude(s) for diagram number 352
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[18], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram353( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 353 OF 1240 ***
    // Wavefunction(s) for diagram number 353
    // (none)
    // Amplitude(s) for diagram number 353
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[19], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram354( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 354 OF 1240 ***
    // Wavefunction(s) for diagram number 354
    // (none)
    // Amplitude(s) for diagram number 354
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[67], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram355( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 355 OF 1240 ***
    // Wavefunction(s) for diagram number 355
    // (none)
    // Amplitude(s) for diagram number 355
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[19], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram356( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 356 OF 1240 ***
    // Wavefunction(s) for diagram number 356
    // (none)
    // Amplitude(s) for diagram number 356
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[29], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[29], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[29], w_fp[92], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram357( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 357 OF 1240 ***
    // Wavefunction(s) for diagram number 357
    // (none)
    // Amplitude(s) for diagram number 357
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[2], w_fp[67], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram358( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 358 OF 1240 ***
    // Wavefunction(s) for diagram number 358
    // (none)
    // Amplitude(s) for diagram number 358
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[18], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram359( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 359 OF 1240 ***
    // Wavefunction(s) for diagram number 359
    // (none)
    // Amplitude(s) for diagram number 359
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[73], w_fp[6], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[79], w_fp[6], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[80], w_fp[6], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram360( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 360 OF 1240 ***
    // Wavefunction(s) for diagram number 360
    // (none)
    // Amplitude(s) for diagram number 360
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[2], w_fp[73], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[2], w_fp[79], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[2], w_fp[80], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram361( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 361 OF 1240 ***
    // Wavefunction(s) for diagram number 361
    // (none)
    // Amplitude(s) for diagram number 361
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[47], w_fp[73], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[47], w_fp[79], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[47], w_fp[80], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram362( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 362 OF 1240 ***
    // Wavefunction(s) for diagram number 362
    // (none)
    // Amplitude(s) for diagram number 362
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[57], w_fp[5], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[81], w_fp[5], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[82], w_fp[5], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram363( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 363 OF 1240 ***
    // Wavefunction(s) for diagram number 363
    // (none)
    // Amplitude(s) for diagram number 363
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[2], w_fp[57], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[2], w_fp[81], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[2], w_fp[82], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram364( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 364 OF 1240 ***
    // Wavefunction(s) for diagram number 364
    // (none)
    // Amplitude(s) for diagram number 364
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[39], w_fp[57], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[39], w_fp[81], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[39], w_fp[82], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram365( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 365 OF 1240 ***
    // Wavefunction(s) for diagram number 365
    // (none)
    // Amplitude(s) for diagram number 365
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[55], w_fp[4], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[83], w_fp[4], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[84], w_fp[4], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram366( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 366 OF 1240 ***
    // Wavefunction(s) for diagram number 366
    // (none)
    // Amplitude(s) for diagram number 366
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[2], w_fp[55], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[2], w_fp[83], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[34], w_fp[2], w_fp[84], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram367( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 367 OF 1240 ***
    // Wavefunction(s) for diagram number 367
    // (none)
    // Amplitude(s) for diagram number 367
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[33], w_fp[55], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[33], w_fp[83], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[33], w_fp[84], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram368( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 368 OF 1240 ***
    // Wavefunction(s) for diagram number 368
    // (none)
    // Amplitude(s) for diagram number 368
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[30], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[31], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[32], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram369( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 369 OF 1240 ***
    // Wavefunction(s) for diagram number 369
    // (none)
    // Amplitude(s) for diagram number 369
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[30], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[31], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[32], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram370( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 370 OF 1240 ***
    // Wavefunction(s) for diagram number 370
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[92] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[99] );
    // Amplitude(s) for diagram number 370
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[9], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram371( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 371 OF 1240 ***
    // Wavefunction(s) for diagram number 371
    // (none)
    // Amplitude(s) for diagram number 371
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[85], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram372( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 372 OF 1240 ***
    // Wavefunction(s) for diagram number 372
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[62] );
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], COUPs[1], 1.0, 0., 0., w_fp[34] );
    // Amplitude(s) for diagram number 372
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[34], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram373( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 373 OF 1240 ***
    // Wavefunction(s) for diagram number 373
    // (none)
    // Amplitude(s) for diagram number 373
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[85], w_fp[62], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram374( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 374 OF 1240 ***
    // Wavefunction(s) for diagram number 374
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[86] );
    // Amplitude(s) for diagram number 374
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[34], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram375( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 375 OF 1240 ***
    // Wavefunction(s) for diagram number 375
    // (none)
    // Amplitude(s) for diagram number 375
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[9], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram376( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 376 OF 1240 ***
    // Wavefunction(s) for diagram number 376
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[88] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[90] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[96] );
    // Amplitude(s) for diagram number 376
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[88], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[96], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram377( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 377 OF 1240 ***
    // Wavefunction(s) for diagram number 377
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[77], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[95] );
    // Amplitude(s) for diagram number 377
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[95], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram378( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 378 OF 1240 ***
    // Wavefunction(s) for diagram number 378
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[38], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[98] );
    // Amplitude(s) for diagram number 378
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[77], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram379( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 379 OF 1240 ***
    // Wavefunction(s) for diagram number 379
    // (none)
    // Amplitude(s) for diagram number 379
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[77], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram380( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 380 OF 1240 ***
    // Wavefunction(s) for diagram number 380
    // (none)
    // Amplitude(s) for diagram number 380
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[95], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram381( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 381 OF 1240 ***
    // Wavefunction(s) for diagram number 381
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[41], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[101] );
    // Amplitude(s) for diagram number 381
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[101], w_fp[77], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram382( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 382 OF 1240 ***
    // Wavefunction(s) for diagram number 382
    // (none)
    // Amplitude(s) for diagram number 382
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[77], w_fp[62], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram383( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 383 OF 1240 ***
    // Wavefunction(s) for diagram number 383
    // (none)
    // Amplitude(s) for diagram number 383
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[95], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram384( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 384 OF 1240 ***
    // Wavefunction(s) for diagram number 384
    // (none)
    // Amplitude(s) for diagram number 384
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[77], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram385( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 385 OF 1240 ***
    // Wavefunction(s) for diagram number 385
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[29], COUPs[0], 1.0, 0., 0., w_fp[95] );
    // Amplitude(s) for diagram number 385
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[95], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram386( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 386 OF 1240 ***
    // Wavefunction(s) for diagram number 386
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[102] );
    // Amplitude(s) for diagram number 386
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[22], w_fp[102], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram387( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 387 OF 1240 ***
    // Wavefunction(s) for diagram number 387
    // (none)
    // Amplitude(s) for diagram number 387
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[102], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram388( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 388 OF 1240 ***
    // Wavefunction(s) for diagram number 388
    FFV1P0_3<W_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], COUPs[1], 1.0, 0., 0., w_fp[103] );
    // Amplitude(s) for diagram number 388
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[103], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram389( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 389 OF 1240 ***
    // Wavefunction(s) for diagram number 389
    // (none)
    // Amplitude(s) for diagram number 389
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[2], w_fp[62], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram390( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 390 OF 1240 ***
    // Wavefunction(s) for diagram number 390
    // (none)
    // Amplitude(s) for diagram number 390
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[103], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram391( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 391 OF 1240 ***
    // Wavefunction(s) for diagram number 391
    // (none)
    // Amplitude(s) for diagram number 391
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[22], w_fp[2], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram392( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 392 OF 1240 ***
    // Wavefunction(s) for diagram number 392
    // (none)
    // Amplitude(s) for diagram number 392
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[88], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[96], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram393( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 393 OF 1240 ***
    // Wavefunction(s) for diagram number 393
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[52], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[104] );
    // Amplitude(s) for diagram number 393
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[39], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram394( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 394 OF 1240 ***
    // Wavefunction(s) for diagram number 394
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[39], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[105] );
    // Amplitude(s) for diagram number 394
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[105], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram395( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 395 OF 1240 ***
    // Wavefunction(s) for diagram number 395
    // (none)
    // Amplitude(s) for diagram number 395
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[39], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram396( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 396 OF 1240 ***
    // Wavefunction(s) for diagram number 396
    // (none)
    // Amplitude(s) for diagram number 396
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[47], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram397( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 397 OF 1240 ***
    // Wavefunction(s) for diagram number 397
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[47], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[106] );
    // Amplitude(s) for diagram number 397
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[106], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram398( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 398 OF 1240 ***
    // Wavefunction(s) for diagram number 398
    // (none)
    // Amplitude(s) for diagram number 398
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[47], w_fp[62], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram399( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 399 OF 1240 ***
    // Wavefunction(s) for diagram number 399
    // (none)
    // Amplitude(s) for diagram number 399
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[2], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram400( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 400 OF 1240 ***
    // Wavefunction(s) for diagram number 400
    // (none)
    // Amplitude(s) for diagram number 400
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[102], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram401( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 401 OF 1240 ***
    // Wavefunction(s) for diagram number 401
    // (none)
    // Amplitude(s) for diagram number 401
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[95], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram402( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 402 OF 1240 ***
    // Wavefunction(s) for diagram number 402
    // (none)
    // Amplitude(s) for diagram number 402
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[102], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram403( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 403 OF 1240 ***
    // Wavefunction(s) for diagram number 403
    // (none)
    // Amplitude(s) for diagram number 403
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[102], w_fp[70], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram404( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 404 OF 1240 ***
    // Wavefunction(s) for diagram number 404
    // (none)
    // Amplitude(s) for diagram number 404
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[94], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram405( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 405 OF 1240 ***
    // Wavefunction(s) for diagram number 405
    // (none)
    // Amplitude(s) for diagram number 405
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[70], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram406( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 406 OF 1240 ***
    // Wavefunction(s) for diagram number 406
    // (none)
    // Amplitude(s) for diagram number 406
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[94], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram407( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 407 OF 1240 ***
    // Wavefunction(s) for diagram number 407
    // (none)
    // Amplitude(s) for diagram number 407
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[2], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram408( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 408 OF 1240 ***
    // Wavefunction(s) for diagram number 408
    // (none)
    // Amplitude(s) for diagram number 408
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[66], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[66], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[66], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram409( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 409 OF 1240 ***
    // Wavefunction(s) for diagram number 409
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[66], COUPs[0], 1.0, 0., 0., w_fp[104] );
    // Amplitude(s) for diagram number 409
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[104], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram410( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 410 OF 1240 ***
    // Wavefunction(s) for diagram number 410
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[8], COUPs[0], 1.0, 0., 0., w_fp[107] );
    // Amplitude(s) for diagram number 410
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[6], w_fp[107], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram411( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 411 OF 1240 ***
    // Wavefunction(s) for diagram number 411
    // (none)
    // Amplitude(s) for diagram number 411
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[8], w_fp[86], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram412( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 412 OF 1240 ***
    // Wavefunction(s) for diagram number 412
    // (none)
    // Amplitude(s) for diagram number 412
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram413( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 413 OF 1240 ***
    // Wavefunction(s) for diagram number 413
    // (none)
    // Amplitude(s) for diagram number 413
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[106], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram414( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 414 OF 1240 ***
    // Wavefunction(s) for diagram number 414
    // (none)
    // Amplitude(s) for diagram number 414
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[47], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram415( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 415 OF 1240 ***
    // Wavefunction(s) for diagram number 415
    // (none)
    // Amplitude(s) for diagram number 415
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram416( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 416 OF 1240 ***
    // Wavefunction(s) for diagram number 416
    // (none)
    // Amplitude(s) for diagram number 416
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[102], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram417( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 417 OF 1240 ***
    // Wavefunction(s) for diagram number 417
    // (none)
    // Amplitude(s) for diagram number 417
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[101], w_fp[2], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram418( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 418 OF 1240 ***
    // Wavefunction(s) for diagram number 418
    // (none)
    // Amplitude(s) for diagram number 418
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[76], w_fp[102], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram419( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 419 OF 1240 ***
    // Wavefunction(s) for diagram number 419
    // (none)
    // Amplitude(s) for diagram number 419
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[102], w_fp[75], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram420( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 420 OF 1240 ***
    // Wavefunction(s) for diagram number 420
    // (none)
    // Amplitude(s) for diagram number 420
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[97], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram421( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 421 OF 1240 ***
    // Wavefunction(s) for diagram number 421
    // (none)
    // Amplitude(s) for diagram number 421
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[75], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram422( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 422 OF 1240 ***
    // Wavefunction(s) for diagram number 422
    // (none)
    // Amplitude(s) for diagram number 422
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[97], w_fp[62], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram423( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 423 OF 1240 ***
    // Wavefunction(s) for diagram number 423
    // (none)
    // Amplitude(s) for diagram number 423
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[76], w_fp[2], w_fp[62], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram424( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 424 OF 1240 ***
    // Wavefunction(s) for diagram number 424
    // (none)
    // Amplitude(s) for diagram number 424
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[72], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[72], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[72], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram425( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 425 OF 1240 ***
    // Wavefunction(s) for diagram number 425
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[72], COUPs[0], 1.0, 0., 0., w_fp[104] );
    // Amplitude(s) for diagram number 425
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[104], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram426( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 426 OF 1240 ***
    // Wavefunction(s) for diagram number 426
    // (none)
    // Amplitude(s) for diagram number 426
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[5], w_fp[107], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram427( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 427 OF 1240 ***
    // Wavefunction(s) for diagram number 427
    // (none)
    // Amplitude(s) for diagram number 427
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[8], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram428( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 428 OF 1240 ***
    // Wavefunction(s) for diagram number 428
    // (none)
    // Amplitude(s) for diagram number 428
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram429( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 429 OF 1240 ***
    // Wavefunction(s) for diagram number 429
    // (none)
    // Amplitude(s) for diagram number 429
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[105], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram430( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 430 OF 1240 ***
    // Wavefunction(s) for diagram number 430
    // (none)
    // Amplitude(s) for diagram number 430
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[39], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram431( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 431 OF 1240 ***
    // Wavefunction(s) for diagram number 431
    // (none)
    // Amplitude(s) for diagram number 431
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram432( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 432 OF 1240 ***
    // Wavefunction(s) for diagram number 432
    // (none)
    // Amplitude(s) for diagram number 432
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[102], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram433( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 433 OF 1240 ***
    // Wavefunction(s) for diagram number 433
    // (none)
    // Amplitude(s) for diagram number 433
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[2], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram434( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 434 OF 1240 ***
    // Wavefunction(s) for diagram number 434
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], COUPs[0], 1.0, 0., 0., w_fp[104] );
    // Amplitude(s) for diagram number 434
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[10], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram435( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 435 OF 1240 ***
    // Wavefunction(s) for diagram number 435
    // (none)
    // Amplitude(s) for diagram number 435
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[11], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram436( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 436 OF 1240 ***
    // Wavefunction(s) for diagram number 436
    // (none)
    // Amplitude(s) for diagram number 436
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[6], w_fp[104], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[6], w_fp[104], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[6], w_fp[104], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram437( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 437 OF 1240 ***
    // Wavefunction(s) for diagram number 437
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], COUPs[0], 1.0, 0., 0., w_fp[108] );
    // Amplitude(s) for diagram number 437
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[108], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram438( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 438 OF 1240 ***
    // Wavefunction(s) for diagram number 438
    // (none)
    // Amplitude(s) for diagram number 438
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[1], w_fp[11], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram439( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 439 OF 1240 ***
    // Wavefunction(s) for diagram number 439
    // (none)
    // Amplitude(s) for diagram number 439
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[6], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[6], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[6], w_fp[62], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram440( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 440 OF 1240 ***
    // Wavefunction(s) for diagram number 440
    // (none)
    // Amplitude(s) for diagram number 440
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[108], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram441( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 441 OF 1240 ***
    // Wavefunction(s) for diagram number 441
    // (none)
    // Amplitude(s) for diagram number 441
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[1], w_fp[10], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram442( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 442 OF 1240 ***
    // Wavefunction(s) for diagram number 442
    // (none)
    // Amplitude(s) for diagram number 442
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[5], w_fp[86], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[5], w_fp[86], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[5], w_fp[86], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram443( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 443 OF 1240 ***
    // Wavefunction(s) for diagram number 443
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[109] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[110] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[111] );
    // Amplitude(s) for diagram number 443
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[109], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[110], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[111], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram444( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 444 OF 1240 ***
    // Wavefunction(s) for diagram number 444
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[112] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[113] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[114] );
    // Amplitude(s) for diagram number 444
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[112], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[113], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[114], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram445( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 445 OF 1240 ***
    // Wavefunction(s) for diagram number 445
    // (none)
    // Amplitude(s) for diagram number 445
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[88], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[90], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[96], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram446( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 446 OF 1240 ***
    // Wavefunction(s) for diagram number 446
    // (none)
    // Amplitude(s) for diagram number 446
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[8], w_fp[29], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[8], w_fp[29], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[8], w_fp[29], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram447( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 447 OF 1240 ***
    // Wavefunction(s) for diagram number 447
    // (none)
    // Amplitude(s) for diagram number 447
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[29], w_fp[104], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram448( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 448 OF 1240 ***
    // Wavefunction(s) for diagram number 448
    // (none)
    // Amplitude(s) for diagram number 448
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[29], w_fp[107], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram449( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 449 OF 1240 ***
    // Wavefunction(s) for diagram number 449
    // (none)
    // Amplitude(s) for diagram number 449
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[95], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram450( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 450 OF 1240 ***
    // Wavefunction(s) for diagram number 450
    // (none)
    // Amplitude(s) for diagram number 450
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[45], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram451( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 451 OF 1240 ***
    // Wavefunction(s) for diagram number 451
    // (none)
    // Amplitude(s) for diagram number 451
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[44], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram452( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 452 OF 1240 ***
    // Wavefunction(s) for diagram number 452
    // (none)
    // Amplitude(s) for diagram number 452
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[89], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram453( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 453 OF 1240 ***
    // Wavefunction(s) for diagram number 453
    // (none)
    // Amplitude(s) for diagram number 453
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[44], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram454( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 454 OF 1240 ***
    // Wavefunction(s) for diagram number 454
    // (none)
    // Amplitude(s) for diagram number 454
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[89], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram455( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 455 OF 1240 ***
    // Wavefunction(s) for diagram number 455
    // (none)
    // Amplitude(s) for diagram number 455
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[1], w_fp[45], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram456( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 456 OF 1240 ***
    // Wavefunction(s) for diagram number 456
    // (none)
    // Amplitude(s) for diagram number 456
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[112], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[113], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[114], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram457( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 457 OF 1240 ***
    // Wavefunction(s) for diagram number 457
    // (none)
    // Amplitude(s) for diagram number 457
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[39], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram458( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 458 OF 1240 ***
    // Wavefunction(s) for diagram number 458
    // (none)
    // Amplitude(s) for diagram number 458
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[105], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram459( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 459 OF 1240 ***
    // Wavefunction(s) for diagram number 459
    // (none)
    // Amplitude(s) for diagram number 459
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[101], w_fp[39], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram460( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 460 OF 1240 ***
    // Wavefunction(s) for diagram number 460
    // (none)
    // Amplitude(s) for diagram number 460
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[51], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram461( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 461 OF 1240 ***
    // Wavefunction(s) for diagram number 461
    // (none)
    // Amplitude(s) for diagram number 461
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[50], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram462( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 462 OF 1240 ***
    // Wavefunction(s) for diagram number 462
    // (none)
    // Amplitude(s) for diagram number 462
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[91], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram463( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 463 OF 1240 ***
    // Wavefunction(s) for diagram number 463
    // (none)
    // Amplitude(s) for diagram number 463
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[50], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram464( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 464 OF 1240 ***
    // Wavefunction(s) for diagram number 464
    // (none)
    // Amplitude(s) for diagram number 464
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[91], w_fp[62], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram465( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 465 OF 1240 ***
    // Wavefunction(s) for diagram number 465
    // (none)
    // Amplitude(s) for diagram number 465
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[1], w_fp[51], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram466( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 466 OF 1240 ***
    // Wavefunction(s) for diagram number 466
    // (none)
    // Amplitude(s) for diagram number 466
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[109], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[110], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[111], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram467( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 467 OF 1240 ***
    // Wavefunction(s) for diagram number 467
    // (none)
    // Amplitude(s) for diagram number 467
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[47], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram468( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 468 OF 1240 ***
    // Wavefunction(s) for diagram number 468
    // (none)
    // Amplitude(s) for diagram number 468
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[106], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram469( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 469 OF 1240 ***
    // Wavefunction(s) for diagram number 469
    // (none)
    // Amplitude(s) for diagram number 469
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[47], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram470( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 470 OF 1240 ***
    // Wavefunction(s) for diagram number 470
    // (none)
    // Amplitude(s) for diagram number 470
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[23], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram471( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 471 OF 1240 ***
    // Wavefunction(s) for diagram number 471
    // (none)
    // Amplitude(s) for diagram number 471
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[2], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram472( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 472 OF 1240 ***
    // Wavefunction(s) for diagram number 472
    // (none)
    // Amplitude(s) for diagram number 472
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[58], w_fp[102], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram473( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 473 OF 1240 ***
    // Wavefunction(s) for diagram number 473
    // (none)
    // Amplitude(s) for diagram number 473
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[102], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram474( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 474 OF 1240 ***
    // Wavefunction(s) for diagram number 474
    // (none)
    // Amplitude(s) for diagram number 474
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[58], w_fp[2], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram475( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 475 OF 1240 ***
    // Wavefunction(s) for diagram number 475
    // (none)
    // Amplitude(s) for diagram number 475
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[1], w_fp[23], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram476( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 476 OF 1240 ***
    // Wavefunction(s) for diagram number 476
    // (none)
    // Amplitude(s) for diagram number 476
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[112], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[113], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[114], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram477( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 477 OF 1240 ***
    // Wavefunction(s) for diagram number 477
    // (none)
    // Amplitude(s) for diagram number 477
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[20], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram478( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 478 OF 1240 ***
    // Wavefunction(s) for diagram number 478
    // (none)
    // Amplitude(s) for diagram number 478
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[2], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram479( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 479 OF 1240 ***
    // Wavefunction(s) for diagram number 479
    // (none)
    // Amplitude(s) for diagram number 479
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[102], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram480( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 480 OF 1240 ***
    // Wavefunction(s) for diagram number 480
    // (none)
    // Amplitude(s) for diagram number 480
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[102], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram481( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 481 OF 1240 ***
    // Wavefunction(s) for diagram number 481
    // (none)
    // Amplitude(s) for diagram number 481
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[2], w_fp[62], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram482( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 482 OF 1240 ***
    // Wavefunction(s) for diagram number 482
    // (none)
    // Amplitude(s) for diagram number 482
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[1], w_fp[20], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram483( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 483 OF 1240 ***
    // Wavefunction(s) for diagram number 483
    // (none)
    // Amplitude(s) for diagram number 483
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[109], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[110], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[111], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram484( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 484 OF 1240 ***
    // Wavefunction(s) for diagram number 484
    // (none)
    // Amplitude(s) for diagram number 484
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[18], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram485( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 485 OF 1240 ***
    // Wavefunction(s) for diagram number 485
    // (none)
    // Amplitude(s) for diagram number 485
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[2], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram486( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 486 OF 1240 ***
    // Wavefunction(s) for diagram number 486
    // (none)
    // Amplitude(s) for diagram number 486
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[102], w_fp[67], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram487( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 487 OF 1240 ***
    // Wavefunction(s) for diagram number 487
    // (none)
    // Amplitude(s) for diagram number 487
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[102], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram488( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 488 OF 1240 ***
    // Wavefunction(s) for diagram number 488
    // (none)
    // Amplitude(s) for diagram number 488
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[67], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram489( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 489 OF 1240 ***
    // Wavefunction(s) for diagram number 489
    // (none)
    // Amplitude(s) for diagram number 489
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[18], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram490( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 490 OF 1240 ***
    // Wavefunction(s) for diagram number 490
    // (none)
    // Amplitude(s) for diagram number 490
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[102], w_fp[55], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[102], w_fp[83], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[102], w_fp[84], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram491( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 491 OF 1240 ***
    // Wavefunction(s) for diagram number 491
    // (none)
    // Amplitude(s) for diagram number 491
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[55], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[83], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[84], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram492( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 492 OF 1240 ***
    // Wavefunction(s) for diagram number 492
    // (none)
    // Amplitude(s) for diagram number 492
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[55], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[83], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[84], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram493( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 493 OF 1240 ***
    // Wavefunction(s) for diagram number 493
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[92] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[99] );
    // Amplitude(s) for diagram number 493
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[87], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram494( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 494 OF 1240 ***
    // Wavefunction(s) for diagram number 494
    // (none)
    // Amplitude(s) for diagram number 494
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[85], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram495( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 495 OF 1240 ***
    // Wavefunction(s) for diagram number 495
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[102] );
    // Amplitude(s) for diagram number 495
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[102], w_fp[34], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram496( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 496 OF 1240 ***
    // Wavefunction(s) for diagram number 496
    // (none)
    // Amplitude(s) for diagram number 496
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[85], w_fp[102], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram497( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 497 OF 1240 ***
    // Wavefunction(s) for diagram number 497
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[104] );
    // Amplitude(s) for diagram number 497
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[34], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram498( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 498 OF 1240 ***
    // Wavefunction(s) for diagram number 498
    // (none)
    // Amplitude(s) for diagram number 498
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[87], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram499( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 499 OF 1240 ***
    // Wavefunction(s) for diagram number 499
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[4], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[111] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[4], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[110] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[4], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[109] );
    // Amplitude(s) for diagram number 499
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[111], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[110], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[109], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram500( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 500 OF 1240 ***
    // Wavefunction(s) for diagram number 500
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[77], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[62] );
    // Amplitude(s) for diagram number 500
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[62], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram501( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 501 OF 1240 ***
    // Wavefunction(s) for diagram number 501
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[46], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[114] );
    // Amplitude(s) for diagram number 501
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[114], w_fp[77], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram502( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 502 OF 1240 ***
    // Wavefunction(s) for diagram number 502
    // (none)
    // Amplitude(s) for diagram number 502
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[77], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram503( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 503 OF 1240 ***
    // Wavefunction(s) for diagram number 503
    // (none)
    // Amplitude(s) for diagram number 503
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[62], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram504( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 504 OF 1240 ***
    // Wavefunction(s) for diagram number 504
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[41], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[113] );
    // Amplitude(s) for diagram number 504
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[113], w_fp[77], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram505( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 505 OF 1240 ***
    // Wavefunction(s) for diagram number 505
    // (none)
    // Amplitude(s) for diagram number 505
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[77], w_fp[102], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram506( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 506 OF 1240 ***
    // Wavefunction(s) for diagram number 506
    // (none)
    // Amplitude(s) for diagram number 506
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[62], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram507( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 507 OF 1240 ***
    // Wavefunction(s) for diagram number 507
    // (none)
    // Amplitude(s) for diagram number 507
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[77], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram508( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 508 OF 1240 ***
    // Wavefunction(s) for diagram number 508
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[27], COUPs[0], 1.0, 0., 0., w_fp[62] );
    // Amplitude(s) for diagram number 508
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[62], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram509( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 509 OF 1240 ***
    // Wavefunction(s) for diagram number 509
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[112] );
    // Amplitude(s) for diagram number 509
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[112], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram510( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 510 OF 1240 ***
    // Wavefunction(s) for diagram number 510
    // (none)
    // Amplitude(s) for diagram number 510
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[112], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram511( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 511 OF 1240 ***
    // Wavefunction(s) for diagram number 511
    // (none)
    // Amplitude(s) for diagram number 511
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[102], w_fp[103], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram512( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 512 OF 1240 ***
    // Wavefunction(s) for diagram number 512
    // (none)
    // Amplitude(s) for diagram number 512
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[2], w_fp[102], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram513( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 513 OF 1240 ***
    // Wavefunction(s) for diagram number 513
    // (none)
    // Amplitude(s) for diagram number 513
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[103], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram514( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 514 OF 1240 ***
    // Wavefunction(s) for diagram number 514
    // (none)
    // Amplitude(s) for diagram number 514
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[2], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram515( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 515 OF 1240 ***
    // Wavefunction(s) for diagram number 515
    // (none)
    // Amplitude(s) for diagram number 515
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[111], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[110], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[109], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram516( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 516 OF 1240 ***
    // Wavefunction(s) for diagram number 516
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[52], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[86] );
    // Amplitude(s) for diagram number 516
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[33], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram517( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 517 OF 1240 ***
    // Wavefunction(s) for diagram number 517
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[33], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[98] );
    // Amplitude(s) for diagram number 517
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[98], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram518( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 518 OF 1240 ***
    // Wavefunction(s) for diagram number 518
    // (none)
    // Amplitude(s) for diagram number 518
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[33], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram519( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 519 OF 1240 ***
    // Wavefunction(s) for diagram number 519
    // (none)
    // Amplitude(s) for diagram number 519
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[47], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram520( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 520 OF 1240 ***
    // Wavefunction(s) for diagram number 520
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[47], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[106] );
    // Amplitude(s) for diagram number 520
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[106], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram521( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 521 OF 1240 ***
    // Wavefunction(s) for diagram number 521
    // (none)
    // Amplitude(s) for diagram number 521
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[47], w_fp[102], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram522( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 522 OF 1240 ***
    // Wavefunction(s) for diagram number 522
    // (none)
    // Amplitude(s) for diagram number 522
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[2], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram523( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 523 OF 1240 ***
    // Wavefunction(s) for diagram number 523
    // (none)
    // Amplitude(s) for diagram number 523
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[112], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram524( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 524 OF 1240 ***
    // Wavefunction(s) for diagram number 524
    // (none)
    // Amplitude(s) for diagram number 524
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[62], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram525( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 525 OF 1240 ***
    // Wavefunction(s) for diagram number 525
    // (none)
    // Amplitude(s) for diagram number 525
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[112], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram526( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 526 OF 1240 ***
    // Wavefunction(s) for diagram number 526
    // (none)
    // Amplitude(s) for diagram number 526
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[112], w_fp[64], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram527( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 527 OF 1240 ***
    // Wavefunction(s) for diagram number 527
    // (none)
    // Amplitude(s) for diagram number 527
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[93], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram528( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 528 OF 1240 ***
    // Wavefunction(s) for diagram number 528
    // (none)
    // Amplitude(s) for diagram number 528
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[64], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram529( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 529 OF 1240 ***
    // Wavefunction(s) for diagram number 529
    // (none)
    // Amplitude(s) for diagram number 529
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[93], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram530( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 530 OF 1240 ***
    // Wavefunction(s) for diagram number 530
    // (none)
    // Amplitude(s) for diagram number 530
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[2], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram531( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 531 OF 1240 ***
    // Wavefunction(s) for diagram number 531
    // (none)
    // Amplitude(s) for diagram number 531
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[61], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[61], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[61], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram532( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 532 OF 1240 ***
    // Wavefunction(s) for diagram number 532
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[61], COUPs[0], 1.0, 0., 0., w_fp[86] );
    // Amplitude(s) for diagram number 532
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[86], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram533( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 533 OF 1240 ***
    // Wavefunction(s) for diagram number 533
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[8], COUPs[0], 1.0, 0., 0., w_fp[101] );
    // Amplitude(s) for diagram number 533
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[6], w_fp[101], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram534( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 534 OF 1240 ***
    // Wavefunction(s) for diagram number 534
    // (none)
    // Amplitude(s) for diagram number 534
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[8], w_fp[104], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram535( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 535 OF 1240 ***
    // Wavefunction(s) for diagram number 535
    // (none)
    // Amplitude(s) for diagram number 535
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram536( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 536 OF 1240 ***
    // Wavefunction(s) for diagram number 536
    // (none)
    // Amplitude(s) for diagram number 536
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[106], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram537( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 537 OF 1240 ***
    // Wavefunction(s) for diagram number 537
    // (none)
    // Amplitude(s) for diagram number 537
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[47], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram538( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 538 OF 1240 ***
    // Wavefunction(s) for diagram number 538
    // (none)
    // Amplitude(s) for diagram number 538
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram539( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 539 OF 1240 ***
    // Wavefunction(s) for diagram number 539
    // (none)
    // Amplitude(s) for diagram number 539
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[112], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram540( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 540 OF 1240 ***
    // Wavefunction(s) for diagram number 540
    // (none)
    // Amplitude(s) for diagram number 540
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[113], w_fp[2], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram541( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 541 OF 1240 ***
    // Wavefunction(s) for diagram number 541
    // (none)
    // Amplitude(s) for diagram number 541
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[76], w_fp[112], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram542( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 542 OF 1240 ***
    // Wavefunction(s) for diagram number 542
    // (none)
    // Amplitude(s) for diagram number 542
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[112], w_fp[74], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram543( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 543 OF 1240 ***
    // Wavefunction(s) for diagram number 543
    // (none)
    // Amplitude(s) for diagram number 543
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[97], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram544( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 544 OF 1240 ***
    // Wavefunction(s) for diagram number 544
    // (none)
    // Amplitude(s) for diagram number 544
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[74], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram545( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 545 OF 1240 ***
    // Wavefunction(s) for diagram number 545
    // (none)
    // Amplitude(s) for diagram number 545
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[97], w_fp[102], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram546( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 546 OF 1240 ***
    // Wavefunction(s) for diagram number 546
    // (none)
    // Amplitude(s) for diagram number 546
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[76], w_fp[2], w_fp[102], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram547( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 547 OF 1240 ***
    // Wavefunction(s) for diagram number 547
    // (none)
    // Amplitude(s) for diagram number 547
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[72], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[72], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[72], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram548( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 548 OF 1240 ***
    // Wavefunction(s) for diagram number 548
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[72], COUPs[0], 1.0, 0., 0., w_fp[86] );
    // Amplitude(s) for diagram number 548
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[86], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram549( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 549 OF 1240 ***
    // Wavefunction(s) for diagram number 549
    // (none)
    // Amplitude(s) for diagram number 549
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[101], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram550( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 550 OF 1240 ***
    // Wavefunction(s) for diagram number 550
    // (none)
    // Amplitude(s) for diagram number 550
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[8], w_fp[102], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram551( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 551 OF 1240 ***
    // Wavefunction(s) for diagram number 551
    // (none)
    // Amplitude(s) for diagram number 551
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram552( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 552 OF 1240 ***
    // Wavefunction(s) for diagram number 552
    // (none)
    // Amplitude(s) for diagram number 552
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[98], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram553( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 553 OF 1240 ***
    // Wavefunction(s) for diagram number 553
    // (none)
    // Amplitude(s) for diagram number 553
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[33], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram554( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 554 OF 1240 ***
    // Wavefunction(s) for diagram number 554
    // (none)
    // Amplitude(s) for diagram number 554
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram555( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 555 OF 1240 ***
    // Wavefunction(s) for diagram number 555
    // (none)
    // Amplitude(s) for diagram number 555
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[112], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram556( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 556 OF 1240 ***
    // Wavefunction(s) for diagram number 556
    // (none)
    // Amplitude(s) for diagram number 556
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[114], w_fp[2], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram557( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 557 OF 1240 ***
    // Wavefunction(s) for diagram number 557
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], COUPs[0], 1.0, 0., 0., w_fp[86] );
    // Amplitude(s) for diagram number 557
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[13], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram558( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 558 OF 1240 ***
    // Wavefunction(s) for diagram number 558
    // (none)
    // Amplitude(s) for diagram number 558
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[11], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram559( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 559 OF 1240 ***
    // Wavefunction(s) for diagram number 559
    // (none)
    // Amplitude(s) for diagram number 559
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[6], w_fp[86], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[6], w_fp[86], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[6], w_fp[86], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram560( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 560 OF 1240 ***
    // Wavefunction(s) for diagram number 560
    // (none)
    // Amplitude(s) for diagram number 560
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[102], w_fp[108], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram561( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 561 OF 1240 ***
    // Wavefunction(s) for diagram number 561
    // (none)
    // Amplitude(s) for diagram number 561
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[102], w_fp[1], w_fp[11], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram562( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 562 OF 1240 ***
    // Wavefunction(s) for diagram number 562
    // (none)
    // Amplitude(s) for diagram number 562
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[6], w_fp[102], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[6], w_fp[102], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[6], w_fp[102], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram563( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 563 OF 1240 ***
    // Wavefunction(s) for diagram number 563
    // (none)
    // Amplitude(s) for diagram number 563
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[108], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram564( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 564 OF 1240 ***
    // Wavefunction(s) for diagram number 564
    // (none)
    // Amplitude(s) for diagram number 564
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[1], w_fp[13], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram565( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 565 OF 1240 ***
    // Wavefunction(s) for diagram number 565
    // (none)
    // Amplitude(s) for diagram number 565
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[4], w_fp[104], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[4], w_fp[104], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[4], w_fp[104], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram566( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 566 OF 1240 ***
    // Wavefunction(s) for diagram number 566
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[105] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[95] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[107] );
    // Amplitude(s) for diagram number 566
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[105], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[95], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[107], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram567( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 567 OF 1240 ***
    // Wavefunction(s) for diagram number 567
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[96] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[90] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[88] );
    // Amplitude(s) for diagram number 567
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[96], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[90], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[88], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram568( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 568 OF 1240 ***
    // Wavefunction(s) for diagram number 568
    // (none)
    // Amplitude(s) for diagram number 568
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[111], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[110], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[109], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram569( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 569 OF 1240 ***
    // Wavefunction(s) for diagram number 569
    // (none)
    // Amplitude(s) for diagram number 569
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[8], w_fp[27], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[8], w_fp[27], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[8], w_fp[27], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram570( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 570 OF 1240 ***
    // Wavefunction(s) for diagram number 570
    // (none)
    // Amplitude(s) for diagram number 570
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[27], w_fp[86], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram571( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 571 OF 1240 ***
    // Wavefunction(s) for diagram number 571
    // (none)
    // Amplitude(s) for diagram number 571
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[101], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram572( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 572 OF 1240 ***
    // Wavefunction(s) for diagram number 572
    // (none)
    // Amplitude(s) for diagram number 572
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram573( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 573 OF 1240 ***
    // Wavefunction(s) for diagram number 573
    // (none)
    // Amplitude(s) for diagram number 573
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[37], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram574( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 574 OF 1240 ***
    // Wavefunction(s) for diagram number 574
    // (none)
    // Amplitude(s) for diagram number 574
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[36], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram575( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 575 OF 1240 ***
    // Wavefunction(s) for diagram number 575
    // (none)
    // Amplitude(s) for diagram number 575
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[100], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram576( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 576 OF 1240 ***
    // Wavefunction(s) for diagram number 576
    // (none)
    // Amplitude(s) for diagram number 576
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[36], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram577( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 577 OF 1240 ***
    // Wavefunction(s) for diagram number 577
    // (none)
    // Amplitude(s) for diagram number 577
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[100], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram578( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 578 OF 1240 ***
    // Wavefunction(s) for diagram number 578
    // (none)
    // Amplitude(s) for diagram number 578
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[1], w_fp[37], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram579( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 579 OF 1240 ***
    // Wavefunction(s) for diagram number 579
    // (none)
    // Amplitude(s) for diagram number 579
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[96], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[88], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram580( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 580 OF 1240 ***
    // Wavefunction(s) for diagram number 580
    // (none)
    // Amplitude(s) for diagram number 580
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[33], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram581( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 581 OF 1240 ***
    // Wavefunction(s) for diagram number 581
    // (none)
    // Amplitude(s) for diagram number 581
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[98], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram582( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 582 OF 1240 ***
    // Wavefunction(s) for diagram number 582
    // (none)
    // Amplitude(s) for diagram number 582
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[113], w_fp[33], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram583( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 583 OF 1240 ***
    // Wavefunction(s) for diagram number 583
    // (none)
    // Amplitude(s) for diagram number 583
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[51], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram584( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 584 OF 1240 ***
    // Wavefunction(s) for diagram number 584
    // (none)
    // Amplitude(s) for diagram number 584
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[49], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram585( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 585 OF 1240 ***
    // Wavefunction(s) for diagram number 585
    // (none)
    // Amplitude(s) for diagram number 585
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[91], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram586( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 586 OF 1240 ***
    // Wavefunction(s) for diagram number 586
    // (none)
    // Amplitude(s) for diagram number 586
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[49], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram587( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 587 OF 1240 ***
    // Wavefunction(s) for diagram number 587
    // (none)
    // Amplitude(s) for diagram number 587
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[91], w_fp[102], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram588( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 588 OF 1240 ***
    // Wavefunction(s) for diagram number 588
    // (none)
    // Amplitude(s) for diagram number 588
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[102], w_fp[1], w_fp[51], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram589( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 589 OF 1240 ***
    // Wavefunction(s) for diagram number 589
    // (none)
    // Amplitude(s) for diagram number 589
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[105], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[95], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[107], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram590( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 590 OF 1240 ***
    // Wavefunction(s) for diagram number 590
    // (none)
    // Amplitude(s) for diagram number 590
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[47], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram591( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 591 OF 1240 ***
    // Wavefunction(s) for diagram number 591
    // (none)
    // Amplitude(s) for diagram number 591
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[106], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram592( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 592 OF 1240 ***
    // Wavefunction(s) for diagram number 592
    // (none)
    // Amplitude(s) for diagram number 592
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[114], w_fp[47], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram593( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 593 OF 1240 ***
    // Wavefunction(s) for diagram number 593
    // (none)
    // Amplitude(s) for diagram number 593
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[54], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram594( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 594 OF 1240 ***
    // Wavefunction(s) for diagram number 594
    // (none)
    // Amplitude(s) for diagram number 594
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[53], w_fp[2], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram595( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 595 OF 1240 ***
    // Wavefunction(s) for diagram number 595
    // (none)
    // Amplitude(s) for diagram number 595
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[78], w_fp[112], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram596( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 596 OF 1240 ***
    // Wavefunction(s) for diagram number 596
    // (none)
    // Amplitude(s) for diagram number 596
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[53], w_fp[112], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram597( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 597 OF 1240 ***
    // Wavefunction(s) for diagram number 597
    // (none)
    // Amplitude(s) for diagram number 597
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[78], w_fp[2], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram598( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 598 OF 1240 ***
    // Wavefunction(s) for diagram number 598
    // (none)
    // Amplitude(s) for diagram number 598
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[1], w_fp[54], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram599( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 599 OF 1240 ***
    // Wavefunction(s) for diagram number 599
    // (none)
    // Amplitude(s) for diagram number 599
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[96], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[88], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram600( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 600 OF 1240 ***
    // Wavefunction(s) for diagram number 600
    // (none)
    // Amplitude(s) for diagram number 600
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[20], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram601( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 601 OF 1240 ***
    // Wavefunction(s) for diagram number 601
    // (none)
    // Amplitude(s) for diagram number 601
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[28], w_fp[2], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram602( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 602 OF 1240 ***
    // Wavefunction(s) for diagram number 602
    // (none)
    // Amplitude(s) for diagram number 602
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[112], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram603( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 603 OF 1240 ***
    // Wavefunction(s) for diagram number 603
    // (none)
    // Amplitude(s) for diagram number 603
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[28], w_fp[112], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram604( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 604 OF 1240 ***
    // Wavefunction(s) for diagram number 604
    // (none)
    // Amplitude(s) for diagram number 604
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[2], w_fp[102], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram605( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 605 OF 1240 ***
    // Wavefunction(s) for diagram number 605
    // (none)
    // Amplitude(s) for diagram number 605
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[102], w_fp[1], w_fp[20], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram606( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 606 OF 1240 ***
    // Wavefunction(s) for diagram number 606
    // (none)
    // Amplitude(s) for diagram number 606
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[105], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[95], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[107], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram607( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 607 OF 1240 ***
    // Wavefunction(s) for diagram number 607
    // (none)
    // Amplitude(s) for diagram number 607
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[15], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram608( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 608 OF 1240 ***
    // Wavefunction(s) for diagram number 608
    // (none)
    // Amplitude(s) for diagram number 608
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[2], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram609( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 609 OF 1240 ***
    // Wavefunction(s) for diagram number 609
    // (none)
    // Amplitude(s) for diagram number 609
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[112], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram610( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 610 OF 1240 ***
    // Wavefunction(s) for diagram number 610
    // (none)
    // Amplitude(s) for diagram number 610
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[112], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram611( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 611 OF 1240 ***
    // Wavefunction(s) for diagram number 611
    // (none)
    // Amplitude(s) for diagram number 611
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram612( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 612 OF 1240 ***
    // Wavefunction(s) for diagram number 612
    // (none)
    // Amplitude(s) for diagram number 612
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[15], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram613( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 613 OF 1240 ***
    // Wavefunction(s) for diagram number 613
    // (none)
    // Amplitude(s) for diagram number 613
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[112], w_fp[57], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[112], w_fp[81], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[112], w_fp[82], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram614( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 614 OF 1240 ***
    // Wavefunction(s) for diagram number 614
    // (none)
    // Amplitude(s) for diagram number 614
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[57], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[81], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[82], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram615( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 615 OF 1240 ***
    // Wavefunction(s) for diagram number 615
    // (none)
    // Amplitude(s) for diagram number 615
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[57], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[81], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[82], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram616( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 616 OF 1240 ***
    // Wavefunction(s) for diagram number 616
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[92] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[99] );
    // Amplitude(s) for diagram number 616
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[87], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram617( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 617 OF 1240 ***
    // Wavefunction(s) for diagram number 617
    // (none)
    // Amplitude(s) for diagram number 617
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[9], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram618( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 618 OF 1240 ***
    // Wavefunction(s) for diagram number 618
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[112] );
    // Amplitude(s) for diagram number 618
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[112], w_fp[34], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram619( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 619 OF 1240 ***
    // Wavefunction(s) for diagram number 619
    // (none)
    // Amplitude(s) for diagram number 619
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[9], w_fp[112], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram620( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 620 OF 1240 ***
    // Wavefunction(s) for diagram number 620
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[86] );
    // Amplitude(s) for diagram number 620
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[34], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram621( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 621 OF 1240 ***
    // Wavefunction(s) for diagram number 621
    // (none)
    // Amplitude(s) for diagram number 621
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[87], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram622( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 622 OF 1240 ***
    // Wavefunction(s) for diagram number 622
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[4], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[107] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[4], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[95] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[4], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[105] );
    // Amplitude(s) for diagram number 622
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[107], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[95], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[105], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram623( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 623 OF 1240 ***
    // Wavefunction(s) for diagram number 623
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[77], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[102] );
    // Amplitude(s) for diagram number 623
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[102], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram624( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 624 OF 1240 ***
    // Wavefunction(s) for diagram number 624
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[46], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[88] );
    // Amplitude(s) for diagram number 624
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[77], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram625( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 625 OF 1240 ***
    // Wavefunction(s) for diagram number 625
    // (none)
    // Amplitude(s) for diagram number 625
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[77], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram626( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 626 OF 1240 ***
    // Wavefunction(s) for diagram number 626
    // (none)
    // Amplitude(s) for diagram number 626
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[102], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram627( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 627 OF 1240 ***
    // Wavefunction(s) for diagram number 627
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[38], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[90] );
    // Amplitude(s) for diagram number 627
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[77], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram628( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 628 OF 1240 ***
    // Wavefunction(s) for diagram number 628
    // (none)
    // Amplitude(s) for diagram number 628
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[77], w_fp[112], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram629( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 629 OF 1240 ***
    // Wavefunction(s) for diagram number 629
    // (none)
    // Amplitude(s) for diagram number 629
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[102], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram630( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 630 OF 1240 ***
    // Wavefunction(s) for diagram number 630
    // (none)
    // Amplitude(s) for diagram number 630
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[77], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram631( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 631 OF 1240 ***
    // Wavefunction(s) for diagram number 631
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[24], COUPs[0], 1.0, 0., 0., w_fp[102] );
    // Amplitude(s) for diagram number 631
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[102], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram632( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 632 OF 1240 ***
    // Wavefunction(s) for diagram number 632
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[96] );
    // Amplitude(s) for diagram number 632
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[96], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram633( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 633 OF 1240 ***
    // Wavefunction(s) for diagram number 633
    // (none)
    // Amplitude(s) for diagram number 633
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[22], w_fp[96], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram634( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 634 OF 1240 ***
    // Wavefunction(s) for diagram number 634
    // (none)
    // Amplitude(s) for diagram number 634
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[112], w_fp[103], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram635( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 635 OF 1240 ***
    // Wavefunction(s) for diagram number 635
    // (none)
    // Amplitude(s) for diagram number 635
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[22], w_fp[2], w_fp[112], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram636( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 636 OF 1240 ***
    // Wavefunction(s) for diagram number 636
    // (none)
    // Amplitude(s) for diagram number 636
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[103], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram637( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 637 OF 1240 ***
    // Wavefunction(s) for diagram number 637
    // (none)
    // Amplitude(s) for diagram number 637
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[2], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram638( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 638 OF 1240 ***
    // Wavefunction(s) for diagram number 638
    // (none)
    // Amplitude(s) for diagram number 638
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[107], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[95], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[105], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram639( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 639 OF 1240 ***
    // Wavefunction(s) for diagram number 639
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[52], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[104] );
    // Amplitude(s) for diagram number 639
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[33], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram640( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 640 OF 1240 ***
    // Wavefunction(s) for diagram number 640
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[33], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[114] );
    // Amplitude(s) for diagram number 640
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[114], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram641( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 641 OF 1240 ***
    // Wavefunction(s) for diagram number 641
    // (none)
    // Amplitude(s) for diagram number 641
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[33], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram642( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 642 OF 1240 ***
    // Wavefunction(s) for diagram number 642
    // (none)
    // Amplitude(s) for diagram number 642
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[39], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram643( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 643 OF 1240 ***
    // Wavefunction(s) for diagram number 643
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[39], w_fp[92], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[106] );
    // Amplitude(s) for diagram number 643
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[106], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram644( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 644 OF 1240 ***
    // Wavefunction(s) for diagram number 644
    // (none)
    // Amplitude(s) for diagram number 644
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[39], w_fp[112], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram645( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 645 OF 1240 ***
    // Wavefunction(s) for diagram number 645
    // (none)
    // Amplitude(s) for diagram number 645
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[2], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram646( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 646 OF 1240 ***
    // Wavefunction(s) for diagram number 646
    // (none)
    // Amplitude(s) for diagram number 646
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[96], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram647( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 647 OF 1240 ***
    // Wavefunction(s) for diagram number 647
    // (none)
    // Amplitude(s) for diagram number 647
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[102], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram648( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 648 OF 1240 ***
    // Wavefunction(s) for diagram number 648
    // (none)
    // Amplitude(s) for diagram number 648
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[96], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram649( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 649 OF 1240 ***
    // Wavefunction(s) for diagram number 649
    // (none)
    // Amplitude(s) for diagram number 649
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[96], w_fp[63], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram650( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 650 OF 1240 ***
    // Wavefunction(s) for diagram number 650
    // (none)
    // Amplitude(s) for diagram number 650
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[93], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram651( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 651 OF 1240 ***
    // Wavefunction(s) for diagram number 651
    // (none)
    // Amplitude(s) for diagram number 651
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[63], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram652( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 652 OF 1240 ***
    // Wavefunction(s) for diagram number 652
    // (none)
    // Amplitude(s) for diagram number 652
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[93], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram653( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 653 OF 1240 ***
    // Wavefunction(s) for diagram number 653
    // (none)
    // Amplitude(s) for diagram number 653
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[2], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram654( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 654 OF 1240 ***
    // Wavefunction(s) for diagram number 654
    // (none)
    // Amplitude(s) for diagram number 654
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[61], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[61], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[61], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram655( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 655 OF 1240 ***
    // Wavefunction(s) for diagram number 655
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[61], COUPs[0], 1.0, 0., 0., w_fp[104] );
    // Amplitude(s) for diagram number 655
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[104], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram656( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 656 OF 1240 ***
    // Wavefunction(s) for diagram number 656
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[8], COUPs[0], 1.0, 0., 0., w_fp[113] );
    // Amplitude(s) for diagram number 656
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[113], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram657( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 657 OF 1240 ***
    // Wavefunction(s) for diagram number 657
    // (none)
    // Amplitude(s) for diagram number 657
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[8], w_fp[86], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram658( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 658 OF 1240 ***
    // Wavefunction(s) for diagram number 658
    // (none)
    // Amplitude(s) for diagram number 658
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram659( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 659 OF 1240 ***
    // Wavefunction(s) for diagram number 659
    // (none)
    // Amplitude(s) for diagram number 659
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[106], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram660( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 660 OF 1240 ***
    // Wavefunction(s) for diagram number 660
    // (none)
    // Amplitude(s) for diagram number 660
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[39], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram661( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 661 OF 1240 ***
    // Wavefunction(s) for diagram number 661
    // (none)
    // Amplitude(s) for diagram number 661
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram662( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 662 OF 1240 ***
    // Wavefunction(s) for diagram number 662
    // (none)
    // Amplitude(s) for diagram number 662
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[96], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram663( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 663 OF 1240 ***
    // Wavefunction(s) for diagram number 663
    // (none)
    // Amplitude(s) for diagram number 663
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[2], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram664( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 664 OF 1240 ***
    // Wavefunction(s) for diagram number 664
    // (none)
    // Amplitude(s) for diagram number 664
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[96], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram665( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 665 OF 1240 ***
    // Wavefunction(s) for diagram number 665
    // (none)
    // Amplitude(s) for diagram number 665
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[96], w_fp[69], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram666( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 666 OF 1240 ***
    // Wavefunction(s) for diagram number 666
    // (none)
    // Amplitude(s) for diagram number 666
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[94], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram667( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 667 OF 1240 ***
    // Wavefunction(s) for diagram number 667
    // (none)
    // Amplitude(s) for diagram number 667
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[69], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram668( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 668 OF 1240 ***
    // Wavefunction(s) for diagram number 668
    // (none)
    // Amplitude(s) for diagram number 668
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[94], w_fp[112], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram669( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 669 OF 1240 ***
    // Wavefunction(s) for diagram number 669
    // (none)
    // Amplitude(s) for diagram number 669
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[2], w_fp[112], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram670( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 670 OF 1240 ***
    // Wavefunction(s) for diagram number 670
    // (none)
    // Amplitude(s) for diagram number 670
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[66], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[66], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[66], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram671( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 671 OF 1240 ***
    // Wavefunction(s) for diagram number 671
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[66], COUPs[0], 1.0, 0., 0., w_fp[104] );
    // Amplitude(s) for diagram number 671
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[104], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram672( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 672 OF 1240 ***
    // Wavefunction(s) for diagram number 672
    // (none)
    // Amplitude(s) for diagram number 672
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[113], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram673( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 673 OF 1240 ***
    // Wavefunction(s) for diagram number 673
    // (none)
    // Amplitude(s) for diagram number 673
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[8], w_fp[112], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram674( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 674 OF 1240 ***
    // Wavefunction(s) for diagram number 674
    // (none)
    // Amplitude(s) for diagram number 674
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram675( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 675 OF 1240 ***
    // Wavefunction(s) for diagram number 675
    // (none)
    // Amplitude(s) for diagram number 675
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[114], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram676( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 676 OF 1240 ***
    // Wavefunction(s) for diagram number 676
    // (none)
    // Amplitude(s) for diagram number 676
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[33], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram677( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 677 OF 1240 ***
    // Wavefunction(s) for diagram number 677
    // (none)
    // Amplitude(s) for diagram number 677
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram678( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 678 OF 1240 ***
    // Wavefunction(s) for diagram number 678
    // (none)
    // Amplitude(s) for diagram number 678
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[96], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram679( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 679 OF 1240 ***
    // Wavefunction(s) for diagram number 679
    // (none)
    // Amplitude(s) for diagram number 679
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[2], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram680( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 680 OF 1240 ***
    // Wavefunction(s) for diagram number 680
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], COUPs[0], 1.0, 0., 0., w_fp[104] );
    // Amplitude(s) for diagram number 680
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[13], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram681( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 681 OF 1240 ***
    // Wavefunction(s) for diagram number 681
    // (none)
    // Amplitude(s) for diagram number 681
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[10], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram682( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 682 OF 1240 ***
    // Wavefunction(s) for diagram number 682
    // (none)
    // Amplitude(s) for diagram number 682
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[5], w_fp[104], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[5], w_fp[104], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[5], w_fp[104], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram683( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 683 OF 1240 ***
    // Wavefunction(s) for diagram number 683
    // (none)
    // Amplitude(s) for diagram number 683
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[112], w_fp[108], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram684( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 684 OF 1240 ***
    // Wavefunction(s) for diagram number 684
    // (none)
    // Amplitude(s) for diagram number 684
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[112], w_fp[1], w_fp[10], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram685( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 685 OF 1240 ***
    // Wavefunction(s) for diagram number 685
    // (none)
    // Amplitude(s) for diagram number 685
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[5], w_fp[112], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[5], w_fp[112], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[5], w_fp[112], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram686( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 686 OF 1240 ***
    // Wavefunction(s) for diagram number 686
    // (none)
    // Amplitude(s) for diagram number 686
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[108], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram687( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 687 OF 1240 ***
    // Wavefunction(s) for diagram number 687
    // (none)
    // Amplitude(s) for diagram number 687
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[1], w_fp[13], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram688( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 688 OF 1240 ***
    // Wavefunction(s) for diagram number 688
    // (none)
    // Amplitude(s) for diagram number 688
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[4], w_fp[86], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[4], w_fp[86], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[4], w_fp[86], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram689( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 689 OF 1240 ***
    // Wavefunction(s) for diagram number 689
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[98] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[62] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[101] );
    // Amplitude(s) for diagram number 689
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[98], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[101], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram690( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 690 OF 1240 ***
    // Wavefunction(s) for diagram number 690
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[109] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[110] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[111] );
    // Amplitude(s) for diagram number 690
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[109], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[110], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[111], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram691( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 691 OF 1240 ***
    // Wavefunction(s) for diagram number 691
    // (none)
    // Amplitude(s) for diagram number 691
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[107], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[95], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[105], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram692( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 692 OF 1240 ***
    // Wavefunction(s) for diagram number 692
    // (none)
    // Amplitude(s) for diagram number 692
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[8], w_fp[24], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[8], w_fp[24], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[1], w_fp[8], w_fp[24], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram693( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 693 OF 1240 ***
    // Wavefunction(s) for diagram number 693
    // (none)
    // Amplitude(s) for diagram number 693
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[24], w_fp[104], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram694( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 694 OF 1240 ***
    // Wavefunction(s) for diagram number 694
    // (none)
    // Amplitude(s) for diagram number 694
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[113], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram695( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 695 OF 1240 ***
    // Wavefunction(s) for diagram number 695
    // (none)
    // Amplitude(s) for diagram number 695
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[102], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram696( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 696 OF 1240 ***
    // Wavefunction(s) for diagram number 696
    // (none)
    // Amplitude(s) for diagram number 696
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[37], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram697( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 697 OF 1240 ***
    // Wavefunction(s) for diagram number 697
    // (none)
    // Amplitude(s) for diagram number 697
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[35], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram698( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 698 OF 1240 ***
    // Wavefunction(s) for diagram number 698
    // (none)
    // Amplitude(s) for diagram number 698
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[100], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram699( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 699 OF 1240 ***
    // Wavefunction(s) for diagram number 699
    // (none)
    // Amplitude(s) for diagram number 699
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[35], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram700( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 700 OF 1240 ***
    // Wavefunction(s) for diagram number 700
    // (none)
    // Amplitude(s) for diagram number 700
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[100], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram701( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 701 OF 1240 ***
    // Wavefunction(s) for diagram number 701
    // (none)
    // Amplitude(s) for diagram number 701
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[1], w_fp[37], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram702( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 702 OF 1240 ***
    // Wavefunction(s) for diagram number 702
    // (none)
    // Amplitude(s) for diagram number 702
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[109], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[110], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[111], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram703( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 703 OF 1240 ***
    // Wavefunction(s) for diagram number 703
    // (none)
    // Amplitude(s) for diagram number 703
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[33], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram704( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 704 OF 1240 ***
    // Wavefunction(s) for diagram number 704
    // (none)
    // Amplitude(s) for diagram number 704
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[114], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram705( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 705 OF 1240 ***
    // Wavefunction(s) for diagram number 705
    // (none)
    // Amplitude(s) for diagram number 705
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[33], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram706( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 706 OF 1240 ***
    // Wavefunction(s) for diagram number 706
    // (none)
    // Amplitude(s) for diagram number 706
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[45], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram707( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 707 OF 1240 ***
    // Wavefunction(s) for diagram number 707
    // (none)
    // Amplitude(s) for diagram number 707
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[43], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram708( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 708 OF 1240 ***
    // Wavefunction(s) for diagram number 708
    // (none)
    // Amplitude(s) for diagram number 708
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[89], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram709( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 709 OF 1240 ***
    // Wavefunction(s) for diagram number 709
    // (none)
    // Amplitude(s) for diagram number 709
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[43], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram710( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 710 OF 1240 ***
    // Wavefunction(s) for diagram number 710
    // (none)
    // Amplitude(s) for diagram number 710
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[89], w_fp[112], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram711( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 711 OF 1240 ***
    // Wavefunction(s) for diagram number 711
    // (none)
    // Amplitude(s) for diagram number 711
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[112], w_fp[1], w_fp[45], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram712( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 712 OF 1240 ***
    // Wavefunction(s) for diagram number 712
    // (none)
    // Amplitude(s) for diagram number 712
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[62], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[101], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram713( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 713 OF 1240 ***
    // Wavefunction(s) for diagram number 713
    // (none)
    // Amplitude(s) for diagram number 713
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[39], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram714( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 714 OF 1240 ***
    // Wavefunction(s) for diagram number 714
    // (none)
    // Amplitude(s) for diagram number 714
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[106], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram715( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 715 OF 1240 ***
    // Wavefunction(s) for diagram number 715
    // (none)
    // Amplitude(s) for diagram number 715
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[88], w_fp[39], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram716( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 716 OF 1240 ***
    // Wavefunction(s) for diagram number 716
    // (none)
    // Amplitude(s) for diagram number 716
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[54], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram717( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 717 OF 1240 ***
    // Wavefunction(s) for diagram number 717
    // (none)
    // Amplitude(s) for diagram number 717
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[2], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram718( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 718 OF 1240 ***
    // Wavefunction(s) for diagram number 718
    // (none)
    // Amplitude(s) for diagram number 718
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[78], w_fp[96], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram719( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 719 OF 1240 ***
    // Wavefunction(s) for diagram number 719
    // (none)
    // Amplitude(s) for diagram number 719
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[96], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram720( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 720 OF 1240 ***
    // Wavefunction(s) for diagram number 720
    // (none)
    // Amplitude(s) for diagram number 720
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[78], w_fp[2], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram721( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 721 OF 1240 ***
    // Wavefunction(s) for diagram number 721
    // (none)
    // Amplitude(s) for diagram number 721
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[86], w_fp[1], w_fp[54], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram722( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 722 OF 1240 ***
    // Wavefunction(s) for diagram number 722
    // (none)
    // Amplitude(s) for diagram number 722
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[109], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[110], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[111], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram723( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 723 OF 1240 ***
    // Wavefunction(s) for diagram number 723
    // (none)
    // Amplitude(s) for diagram number 723
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[23], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram724( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 724 OF 1240 ***
    // Wavefunction(s) for diagram number 724
    // (none)
    // Amplitude(s) for diagram number 724
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[25], w_fp[2], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram725( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 725 OF 1240 ***
    // Wavefunction(s) for diagram number 725
    // (none)
    // Amplitude(s) for diagram number 725
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[58], w_fp[96], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram726( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 726 OF 1240 ***
    // Wavefunction(s) for diagram number 726
    // (none)
    // Amplitude(s) for diagram number 726
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[25], w_fp[96], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram727( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 727 OF 1240 ***
    // Wavefunction(s) for diagram number 727
    // (none)
    // Amplitude(s) for diagram number 727
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[58], w_fp[2], w_fp[112], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram728( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 728 OF 1240 ***
    // Wavefunction(s) for diagram number 728
    // (none)
    // Amplitude(s) for diagram number 728
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[112], w_fp[1], w_fp[23], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram729( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 729 OF 1240 ***
    // Wavefunction(s) for diagram number 729
    // (none)
    // Amplitude(s) for diagram number 729
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[62], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[101], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram730( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 730 OF 1240 ***
    // Wavefunction(s) for diagram number 730
    // (none)
    // Amplitude(s) for diagram number 730
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[17], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram731( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 731 OF 1240 ***
    // Wavefunction(s) for diagram number 731
    // (none)
    // Amplitude(s) for diagram number 731
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[26], w_fp[2], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram732( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 732 OF 1240 ***
    // Wavefunction(s) for diagram number 732
    // (none)
    // Amplitude(s) for diagram number 732
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[96], w_fp[59], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram733( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 733 OF 1240 ***
    // Wavefunction(s) for diagram number 733
    // (none)
    // Amplitude(s) for diagram number 733
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[26], w_fp[96], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram734( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 734 OF 1240 ***
    // Wavefunction(s) for diagram number 734
    // (none)
    // Amplitude(s) for diagram number 734
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[59], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram735( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 735 OF 1240 ***
    // Wavefunction(s) for diagram number 735
    // (none)
    // Amplitude(s) for diagram number 735
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[17], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram736( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 736 OF 1240 ***
    // Wavefunction(s) for diagram number 736
    // (none)
    // Amplitude(s) for diagram number 736
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[96], w_fp[73], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[96], w_fp[79], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[96], w_fp[80], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram737( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 737 OF 1240 ***
    // Wavefunction(s) for diagram number 737
    // (none)
    // Amplitude(s) for diagram number 737
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[73], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[79], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[80], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram738( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 738 OF 1240 ***
    // Wavefunction(s) for diagram number 738
    // (none)
    // Amplitude(s) for diagram number 738
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[73], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[79], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[92], w_fp[80], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram739( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 739 OF 1240 ***
    // Wavefunction(s) for diagram number 739
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[77], w_fp[0], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[92] );
    // Amplitude(s) for diagram number 739
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[92], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram740( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 740 OF 1240 ***
    // Wavefunction(s) for diagram number 740
    // (none)
    // Amplitude(s) for diagram number 740
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[53], w_fp[92], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram741( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 741 OF 1240 ***
    // Wavefunction(s) for diagram number 741
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[46], w_fp[0], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[99] );
    // Amplitude(s) for diagram number 741
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[9], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram742( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 742 OF 1240 ***
    // Wavefunction(s) for diagram number 742
    // (none)
    // Amplitude(s) for diagram number 742
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[85], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram743( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 743 OF 1240 ***
    // Wavefunction(s) for diagram number 743
    // (none)
    // Amplitude(s) for diagram number 743
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[53], w_fp[9], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram744( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 744 OF 1240 ***
    // Wavefunction(s) for diagram number 744
    // (none)
    // Amplitude(s) for diagram number 744
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[85], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram745( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 745 OF 1240 ***
    // Wavefunction(s) for diagram number 745
    // (none)
    // Amplitude(s) for diagram number 745
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[92], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram746( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 746 OF 1240 ***
    // Wavefunction(s) for diagram number 746
    // (none)
    // Amplitude(s) for diagram number 746
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[77], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram747( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 747 OF 1240 ***
    // Wavefunction(s) for diagram number 747
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[29], COUPs[0], 1.0, 0., 0., w_fp[96] );
    // Amplitude(s) for diagram number 747
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[77], w_fp[96], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram748( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 748 OF 1240 ***
    // Wavefunction(s) for diagram number 748
    // (none)
    // Amplitude(s) for diagram number 748
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[25], w_fp[92], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram749( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 749 OF 1240 ***
    // Wavefunction(s) for diagram number 749
    // (none)
    // Amplitude(s) for diagram number 749
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[92], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram750( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 750 OF 1240 ***
    // Wavefunction(s) for diagram number 750
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[38], w_fp[0], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[104] );
    // Amplitude(s) for diagram number 750
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[87], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram751( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 751 OF 1240 ***
    // Wavefunction(s) for diagram number 751
    // (none)
    // Amplitude(s) for diagram number 751
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[85], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram752( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 752 OF 1240 ***
    // Wavefunction(s) for diagram number 752
    // (none)
    // Amplitude(s) for diagram number 752
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[87], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram753( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 753 OF 1240 ***
    // Wavefunction(s) for diagram number 753
    // (none)
    // Amplitude(s) for diagram number 753
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[25], w_fp[85], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram754( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 754 OF 1240 ***
    // Wavefunction(s) for diagram number 754
    // (none)
    // Amplitude(s) for diagram number 754
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[92], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram755( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 755 OF 1240 ***
    // Wavefunction(s) for diagram number 755
    // (none)
    // Amplitude(s) for diagram number 755
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[77], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram756( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 756 OF 1240 ***
    // Wavefunction(s) for diagram number 756
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[27], COUPs[0], 1.0, 0., 0., w_fp[101] );
    // Amplitude(s) for diagram number 756
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[77], w_fp[101], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram757( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 757 OF 1240 ***
    // Wavefunction(s) for diagram number 757
    // (none)
    // Amplitude(s) for diagram number 757
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[28], w_fp[92], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram758( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 758 OF 1240 ***
    // Wavefunction(s) for diagram number 758
    // (none)
    // Amplitude(s) for diagram number 758
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[92], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram759( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 759 OF 1240 ***
    // Wavefunction(s) for diagram number 759
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[41], w_fp[0], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[62] );
    // Amplitude(s) for diagram number 759
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[87], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram760( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 760 OF 1240 ***
    // Wavefunction(s) for diagram number 760
    // (none)
    // Amplitude(s) for diagram number 760
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[9], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram761( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 761 OF 1240 ***
    // Wavefunction(s) for diagram number 761
    // (none)
    // Amplitude(s) for diagram number 761
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[87], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram762( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 762 OF 1240 ***
    // Wavefunction(s) for diagram number 762
    // (none)
    // Amplitude(s) for diagram number 762
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[28], w_fp[9], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram763( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 763 OF 1240 ***
    // Wavefunction(s) for diagram number 763
    // (none)
    // Amplitude(s) for diagram number 763
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[92], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram764( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 764 OF 1240 ***
    // Wavefunction(s) for diagram number 764
    // (none)
    // Amplitude(s) for diagram number 764
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[77], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram765( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 765 OF 1240 ***
    // Wavefunction(s) for diagram number 765
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[24], COUPs[0], 1.0, 0., 0., w_fp[98] );
    // Amplitude(s) for diagram number 765
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[77], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram766( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 766 OF 1240 ***
    // Wavefunction(s) for diagram number 766
    // (none)
    // Amplitude(s) for diagram number 766
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[26], w_fp[92], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram767( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 767 OF 1240 ***
    // Wavefunction(s) for diagram number 767
    // (none)
    // Amplitude(s) for diagram number 767
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[92], w_fp[42], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram768( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 768 OF 1240 ***
    // Wavefunction(s) for diagram number 768
    // (none)
    // Amplitude(s) for diagram number 768
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[34], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram769( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 769 OF 1240 ***
    // Wavefunction(s) for diagram number 769
    // (none)
    // Amplitude(s) for diagram number 769
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[85], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram770( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 770 OF 1240 ***
    // Wavefunction(s) for diagram number 770
    // (none)
    // Amplitude(s) for diagram number 770
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[34], w_fp[42], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram771( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 771 OF 1240 ***
    // Wavefunction(s) for diagram number 771
    // (none)
    // Amplitude(s) for diagram number 771
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[26], w_fp[85], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram772( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 772 OF 1240 ***
    // Wavefunction(s) for diagram number 772
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[24], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[85] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[24], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[112] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[24], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[111] );
    // Amplitude(s) for diagram number 772
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[85], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[112], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[111], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram773( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 773 OF 1240 ***
    // Wavefunction(s) for diagram number 773
    // (none)
    // Amplitude(s) for diagram number 773
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[92], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram774( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 774 OF 1240 ***
    // Wavefunction(s) for diagram number 774
    // (none)
    // Amplitude(s) for diagram number 774
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[92], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram775( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 775 OF 1240 ***
    // Wavefunction(s) for diagram number 775
    // (none)
    // Amplitude(s) for diagram number 775
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[101], w_fp[34], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram776( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 776 OF 1240 ***
    // Wavefunction(s) for diagram number 776
    // (none)
    // Amplitude(s) for diagram number 776
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[9], w_fp[101], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram777( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 777 OF 1240 ***
    // Wavefunction(s) for diagram number 777
    // (none)
    // Amplitude(s) for diagram number 777
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[34], w_fp[16], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram778( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 778 OF 1240 ***
    // Wavefunction(s) for diagram number 778
    // (none)
    // Amplitude(s) for diagram number 778
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[9], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram779( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 779 OF 1240 ***
    // Wavefunction(s) for diagram number 779
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[27], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[9] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[27], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[110] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[27], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[109] );
    // Amplitude(s) for diagram number 779
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[9], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[110], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[109], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram780( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 780 OF 1240 ***
    // Wavefunction(s) for diagram number 780
    // (none)
    // Amplitude(s) for diagram number 780
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[92], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram781( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 781 OF 1240 ***
    // Wavefunction(s) for diagram number 781
    // (none)
    // Amplitude(s) for diagram number 781
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[92], w_fp[19], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram782( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 782 OF 1240 ***
    // Wavefunction(s) for diagram number 782
    // (none)
    // Amplitude(s) for diagram number 782
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[96], w_fp[34], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram783( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 783 OF 1240 ***
    // Wavefunction(s) for diagram number 783
    // (none)
    // Amplitude(s) for diagram number 783
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[87], w_fp[96], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram784( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 784 OF 1240 ***
    // Wavefunction(s) for diagram number 784
    // (none)
    // Amplitude(s) for diagram number 784
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[34], w_fp[19], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram785( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 785 OF 1240 ***
    // Wavefunction(s) for diagram number 785
    // (none)
    // Amplitude(s) for diagram number 785
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[87], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram786( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 786 OF 1240 ***
    // Wavefunction(s) for diagram number 786
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[4], w_fp[29], COUPs[2], 1.0, 0., 0., w_fp[87] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[4], w_fp[29], COUPs[2], 1.0, 0., 0., w_fp[34] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[4], w_fp[29], COUPs[2], 1.0, 0., 0., w_fp[86] );
    // Amplitude(s) for diagram number 786
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[87], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[34], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram787( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 787 OF 1240 ***
    // Wavefunction(s) for diagram number 787
    // (none)
    // Amplitude(s) for diagram number 787
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[92], w_fp[30], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[92], w_fp[31], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[92], w_fp[32], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram788( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 788 OF 1240 ***
    // Wavefunction(s) for diagram number 788
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[30], COUPs[0], 1.0, 0., 0., w_fp[92] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[31], COUPs[0], 1.0, 0., 0., w_fp[88] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[32], COUPs[0], 1.0, 0., 0., w_fp[106] );
    // Amplitude(s) for diagram number 788
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[92], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[88], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[106], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram789( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 789 OF 1240 ***
    // Wavefunction(s) for diagram number 789
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[52], w_fp[0], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[90] );
    // Amplitude(s) for diagram number 789
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[35], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram790( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 790 OF 1240 ***
    // Wavefunction(s) for diagram number 790
    // (none)
    // Amplitude(s) for diagram number 790
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[36], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram791( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 791 OF 1240 ***
    // Wavefunction(s) for diagram number 791
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[33], w_fp[0], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[114] );
    // Amplitude(s) for diagram number 791
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[22], w_fp[114], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram792( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 792 OF 1240 ***
    // Wavefunction(s) for diagram number 792
    // (none)
    // Amplitude(s) for diagram number 792
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[114], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram793( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 793 OF 1240 ***
    // Wavefunction(s) for diagram number 793
    // (none)
    // Amplitude(s) for diagram number 793
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[22], w_fp[36], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram794( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 794 OF 1240 ***
    // Wavefunction(s) for diagram number 794
    // (none)
    // Amplitude(s) for diagram number 794
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[35], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram795( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 795 OF 1240 ***
    // Wavefunction(s) for diagram number 795
    // (none)
    // Amplitude(s) for diagram number 795
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[33], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram796( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 796 OF 1240 ***
    // Wavefunction(s) for diagram number 796
    // (none)
    // Amplitude(s) for diagram number 796
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[114], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram797( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 797 OF 1240 ***
    // Wavefunction(s) for diagram number 797
    // (none)
    // Amplitude(s) for diagram number 797
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[33], w_fp[96], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram798( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 798 OF 1240 ***
    // Wavefunction(s) for diagram number 798
    // (none)
    // Amplitude(s) for diagram number 798
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[43], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram799( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 799 OF 1240 ***
    // Wavefunction(s) for diagram number 799
    // (none)
    // Amplitude(s) for diagram number 799
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[44], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram800( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 800 OF 1240 ***
    // Wavefunction(s) for diagram number 800
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[39], w_fp[0], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[102] );
    // Amplitude(s) for diagram number 800
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[102], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram801( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 801 OF 1240 ***
    // Wavefunction(s) for diagram number 801
    // (none)
    // Amplitude(s) for diagram number 801
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[102], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram802( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 802 OF 1240 ***
    // Wavefunction(s) for diagram number 802
    // (none)
    // Amplitude(s) for diagram number 802
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[44], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram803( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 803 OF 1240 ***
    // Wavefunction(s) for diagram number 803
    // (none)
    // Amplitude(s) for diagram number 803
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[43], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram804( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 804 OF 1240 ***
    // Wavefunction(s) for diagram number 804
    // (none)
    // Amplitude(s) for diagram number 804
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[39], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram805( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 805 OF 1240 ***
    // Wavefunction(s) for diagram number 805
    // (none)
    // Amplitude(s) for diagram number 805
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[102], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram806( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 806 OF 1240 ***
    // Wavefunction(s) for diagram number 806
    // (none)
    // Amplitude(s) for diagram number 806
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[39], w_fp[101], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram807( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 807 OF 1240 ***
    // Wavefunction(s) for diagram number 807
    // (none)
    // Amplitude(s) for diagram number 807
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[49], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram808( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 808 OF 1240 ***
    // Wavefunction(s) for diagram number 808
    // (none)
    // Amplitude(s) for diagram number 808
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[50], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram809( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 809 OF 1240 ***
    // Wavefunction(s) for diagram number 809
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[47], w_fp[0], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[113] );
    // Amplitude(s) for diagram number 809
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[113], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram810( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 810 OF 1240 ***
    // Wavefunction(s) for diagram number 810
    // (none)
    // Amplitude(s) for diagram number 810
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[22], w_fp[113], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram811( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 811 OF 1240 ***
    // Wavefunction(s) for diagram number 811
    // (none)
    // Amplitude(s) for diagram number 811
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[50], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram812( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 812 OF 1240 ***
    // Wavefunction(s) for diagram number 812
    // (none)
    // Amplitude(s) for diagram number 812
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[22], w_fp[49], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram813( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 813 OF 1240 ***
    // Wavefunction(s) for diagram number 813
    // (none)
    // Amplitude(s) for diagram number 813
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[47], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram814( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 814 OF 1240 ***
    // Wavefunction(s) for diagram number 814
    // (none)
    // Amplitude(s) for diagram number 814
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[113], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram815( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 815 OF 1240 ***
    // Wavefunction(s) for diagram number 815
    // (none)
    // Amplitude(s) for diagram number 815
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[47], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram816( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 816 OF 1240 ***
    // Wavefunction(s) for diagram number 816
    // (none)
    // Amplitude(s) for diagram number 816
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[17], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram817( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 817 OF 1240 ***
    // Wavefunction(s) for diagram number 817
    // (none)
    // Amplitude(s) for diagram number 817
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[2], w_fp[42], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram818( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 818 OF 1240 ***
    // Wavefunction(s) for diagram number 818
    // (none)
    // Amplitude(s) for diagram number 818
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[103], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram819( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 819 OF 1240 ***
    // Wavefunction(s) for diagram number 819
    // (none)
    // Amplitude(s) for diagram number 819
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[2], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram820( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 820 OF 1240 ***
    // Wavefunction(s) for diagram number 820
    // (none)
    // Amplitude(s) for diagram number 820
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[103], w_fp[42], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram821( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 821 OF 1240 ***
    // Wavefunction(s) for diagram number 821
    // (none)
    // Amplitude(s) for diagram number 821
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[17], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram822( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 822 OF 1240 ***
    // Wavefunction(s) for diagram number 822
    // (none)
    // Amplitude(s) for diagram number 822
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[85], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[112], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[111], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram823( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 823 OF 1240 ***
    // Wavefunction(s) for diagram number 823
    // (none)
    // Amplitude(s) for diagram number 823
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[15], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram824( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 824 OF 1240 ***
    // Wavefunction(s) for diagram number 824
    // (none)
    // Amplitude(s) for diagram number 824
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[2], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram825( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 825 OF 1240 ***
    // Wavefunction(s) for diagram number 825
    // (none)
    // Amplitude(s) for diagram number 825
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[101], w_fp[103], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram826( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 826 OF 1240 ***
    // Wavefunction(s) for diagram number 826
    // (none)
    // Amplitude(s) for diagram number 826
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[22], w_fp[2], w_fp[101], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram827( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 827 OF 1240 ***
    // Wavefunction(s) for diagram number 827
    // (none)
    // Amplitude(s) for diagram number 827
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[103], w_fp[16], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram828( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 828 OF 1240 ***
    // Wavefunction(s) for diagram number 828
    // (none)
    // Amplitude(s) for diagram number 828
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[22], w_fp[15], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram829( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 829 OF 1240 ***
    // Wavefunction(s) for diagram number 829
    // (none)
    // Amplitude(s) for diagram number 829
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[9], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[110], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[109], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram830( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 830 OF 1240 ***
    // Wavefunction(s) for diagram number 830
    // (none)
    // Amplitude(s) for diagram number 830
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[18], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram831( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 831 OF 1240 ***
    // Wavefunction(s) for diagram number 831
    // (none)
    // Amplitude(s) for diagram number 831
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[2], w_fp[19], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram832( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 832 OF 1240 ***
    // Wavefunction(s) for diagram number 832
    // (none)
    // Amplitude(s) for diagram number 832
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[96], w_fp[103], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram833( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 833 OF 1240 ***
    // Wavefunction(s) for diagram number 833
    // (none)
    // Amplitude(s) for diagram number 833
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[2], w_fp[96], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram834( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 834 OF 1240 ***
    // Wavefunction(s) for diagram number 834
    // (none)
    // Amplitude(s) for diagram number 834
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[103], w_fp[19], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram835( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 835 OF 1240 ***
    // Wavefunction(s) for diagram number 835
    // (none)
    // Amplitude(s) for diagram number 835
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[18], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram836( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 836 OF 1240 ***
    // Wavefunction(s) for diagram number 836
    // (none)
    // Amplitude(s) for diagram number 836
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[87], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[34], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[86], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram837( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 837 OF 1240 ***
    // Wavefunction(s) for diagram number 837
    // (none)
    // Amplitude(s) for diagram number 837
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[2], w_fp[30], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[2], w_fp[31], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[2], w_fp[32], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram838( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 838 OF 1240 ***
    // Wavefunction(s) for diagram number 838
    // (none)
    // Amplitude(s) for diagram number 838
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[92], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[88], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[106], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram839( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 839 OF 1240 ***
    // Wavefunction(s) for diagram number 839
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[61], COUPs[0], 1.0, 0., 0., w_fp[90] );
    // Amplitude(s) for diagram number 839
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[10], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram840( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 840 OF 1240 ***
    // Wavefunction(s) for diagram number 840
    // (none)
    // Amplitude(s) for diagram number 840
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[11], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram841( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 841 OF 1240 ***
    // Wavefunction(s) for diagram number 841
    // (none)
    // Amplitude(s) for diagram number 841
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[6], w_fp[90], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[6], w_fp[90], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[6], w_fp[90], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram842( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 842 OF 1240 ***
    // Wavefunction(s) for diagram number 842
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[8], COUPs[0], 1.0, 0., 0., w_fp[56] );
    // Amplitude(s) for diagram number 842
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[63], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram843( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 843 OF 1240 ***
    // Wavefunction(s) for diagram number 843
    // (none)
    // Amplitude(s) for diagram number 843
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[64], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram844( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 844 OF 1240 ***
    // Wavefunction(s) for diagram number 844
    // (none)
    // Amplitude(s) for diagram number 844
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[6], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[6], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[6], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram845( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 845 OF 1240 ***
    // Wavefunction(s) for diagram number 845
    // (none)
    // Amplitude(s) for diagram number 845
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[63], w_fp[11], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram846( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 846 OF 1240 ***
    // Wavefunction(s) for diagram number 846
    // (none)
    // Amplitude(s) for diagram number 846
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[64], w_fp[10], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram847( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 847 OF 1240 ***
    // Wavefunction(s) for diagram number 847
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[61], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[103] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[61], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[22] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[61], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[21] );
    // Amplitude(s) for diagram number 847
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[103], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[22], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[21], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram848( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 848 OF 1240 ***
    // Wavefunction(s) for diagram number 848
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[61], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[105] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[61], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[95] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[61], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[107] );
    // Amplitude(s) for diagram number 848
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[105], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[95], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[107], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram849( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 849 OF 1240 ***
    // Wavefunction(s) for diagram number 849
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[8], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[115] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[8], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[116] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[8], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[117] );
    // Amplitude(s) for diagram number 849
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[6], w_fp[115], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[6], w_fp[116], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[6], w_fp[117], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram850( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 850 OF 1240 ***
    // Wavefunction(s) for diagram number 850
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[8], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[118] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[8], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[119] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[8], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[120] );
    // Amplitude(s) for diagram number 850
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[118], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[119], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[5], w_fp[120], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram851( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 851 OF 1240 ***
    // Wavefunction(s) for diagram number 851
    // (none)
    // Amplitude(s) for diagram number 851
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[61], w_fp[8], w_fp[29], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[61], w_fp[8], w_fp[29], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[61], w_fp[8], w_fp[29], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram852( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 852 OF 1240 ***
    // Wavefunction(s) for diagram number 852
    // (none)
    // Amplitude(s) for diagram number 852
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[29], w_fp[90], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram853( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 853 OF 1240 ***
    // Wavefunction(s) for diagram number 853
    // (none)
    // Amplitude(s) for diagram number 853
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[29], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram854( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 854 OF 1240 ***
    // Wavefunction(s) for diagram number 854
    // (none)
    // Amplitude(s) for diagram number 854
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[61], w_fp[8], w_fp[96], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram855( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 855 OF 1240 ***
    // Wavefunction(s) for diagram number 855
    // (none)
    // Amplitude(s) for diagram number 855
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[45], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram856( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 856 OF 1240 ***
    // Wavefunction(s) for diagram number 856
    // (none)
    // Amplitude(s) for diagram number 856
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[44], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram857( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 857 OF 1240 ***
    // Wavefunction(s) for diagram number 857
    // (none)
    // Amplitude(s) for diagram number 857
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[102], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram858( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 858 OF 1240 ***
    // Wavefunction(s) for diagram number 858
    // (none)
    // Amplitude(s) for diagram number 858
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[102], w_fp[64], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram859( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 859 OF 1240 ***
    // Wavefunction(s) for diagram number 859
    // (none)
    // Amplitude(s) for diagram number 859
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[44], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram860( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 860 OF 1240 ***
    // Wavefunction(s) for diagram number 860
    // (none)
    // Amplitude(s) for diagram number 860
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[64], w_fp[45], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram861( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 861 OF 1240 ***
    // Wavefunction(s) for diagram number 861
    // (none)
    // Amplitude(s) for diagram number 861
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[105], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[95], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[107], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram862( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 862 OF 1240 ***
    // Wavefunction(s) for diagram number 862
    // (none)
    // Amplitude(s) for diagram number 862
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[39], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram863( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 863 OF 1240 ***
    // Wavefunction(s) for diagram number 863
    // (none)
    // Amplitude(s) for diagram number 863
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[102], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram864( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 864 OF 1240 ***
    // Wavefunction(s) for diagram number 864
    // (none)
    // Amplitude(s) for diagram number 864
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[39], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram865( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 865 OF 1240 ***
    // Wavefunction(s) for diagram number 865
    // (none)
    // Amplitude(s) for diagram number 865
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[51], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram866( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 866 OF 1240 ***
    // Wavefunction(s) for diagram number 866
    // (none)
    // Amplitude(s) for diagram number 866
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[50], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram867( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 867 OF 1240 ***
    // Wavefunction(s) for diagram number 867
    // (none)
    // Amplitude(s) for diagram number 867
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[113], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram868( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 868 OF 1240 ***
    // Wavefunction(s) for diagram number 868
    // (none)
    // Amplitude(s) for diagram number 868
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[113], w_fp[63], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram869( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 869 OF 1240 ***
    // Wavefunction(s) for diagram number 869
    // (none)
    // Amplitude(s) for diagram number 869
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[50], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram870( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 870 OF 1240 ***
    // Wavefunction(s) for diagram number 870
    // (none)
    // Amplitude(s) for diagram number 870
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[63], w_fp[51], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram871( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 871 OF 1240 ***
    // Wavefunction(s) for diagram number 871
    // (none)
    // Amplitude(s) for diagram number 871
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[103], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[22], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram872( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 872 OF 1240 ***
    // Wavefunction(s) for diagram number 872
    // (none)
    // Amplitude(s) for diagram number 872
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[47], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram873( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 873 OF 1240 ***
    // Wavefunction(s) for diagram number 873
    // (none)
    // Amplitude(s) for diagram number 873
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[113], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram874( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 874 OF 1240 ***
    // Wavefunction(s) for diagram number 874
    // (none)
    // Amplitude(s) for diagram number 874
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[47], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram875( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 875 OF 1240 ***
    // Wavefunction(s) for diagram number 875
    // (none)
    // Amplitude(s) for diagram number 875
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[23], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram876( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 876 OF 1240 ***
    // Wavefunction(s) for diagram number 876
    // (none)
    // Amplitude(s) for diagram number 876
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[2], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram877( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 877 OF 1240 ***
    // Wavefunction(s) for diagram number 877
    // (none)
    // Amplitude(s) for diagram number 877
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[93], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram878( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 878 OF 1240 ***
    // Wavefunction(s) for diagram number 878
    // (none)
    // Amplitude(s) for diagram number 878
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[2], w_fp[64], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram879( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 879 OF 1240 ***
    // Wavefunction(s) for diagram number 879
    // (none)
    // Amplitude(s) for diagram number 879
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[93], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram880( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 880 OF 1240 ***
    // Wavefunction(s) for diagram number 880
    // (none)
    // Amplitude(s) for diagram number 880
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[64], w_fp[23], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram881( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 881 OF 1240 ***
    // Wavefunction(s) for diagram number 881
    // (none)
    // Amplitude(s) for diagram number 881
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[105], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[95], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[107], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram882( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 882 OF 1240 ***
    // Wavefunction(s) for diagram number 882
    // (none)
    // Amplitude(s) for diagram number 882
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[90], w_fp[20], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram883( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 883 OF 1240 ***
    // Wavefunction(s) for diagram number 883
    // (none)
    // Amplitude(s) for diagram number 883
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[2], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram884( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 884 OF 1240 ***
    // Wavefunction(s) for diagram number 884
    // (none)
    // Amplitude(s) for diagram number 884
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[93], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram885( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 885 OF 1240 ***
    // Wavefunction(s) for diagram number 885
    // (none)
    // Amplitude(s) for diagram number 885
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[2], w_fp[63], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram886( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 886 OF 1240 ***
    // Wavefunction(s) for diagram number 886
    // (none)
    // Amplitude(s) for diagram number 886
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[93], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram887( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 887 OF 1240 ***
    // Wavefunction(s) for diagram number 887
    // (none)
    // Amplitude(s) for diagram number 887
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[63], w_fp[20], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram888( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 888 OF 1240 ***
    // Wavefunction(s) for diagram number 888
    // (none)
    // Amplitude(s) for diagram number 888
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[103], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[22], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram889( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 889 OF 1240 ***
    // Wavefunction(s) for diagram number 889
    // (none)
    // Amplitude(s) for diagram number 889
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[18], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram890( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 890 OF 1240 ***
    // Wavefunction(s) for diagram number 890
    // (none)
    // Amplitude(s) for diagram number 890
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[2], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram891( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 891 OF 1240 ***
    // Wavefunction(s) for diagram number 891
    // (none)
    // Amplitude(s) for diagram number 891
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[93], w_fp[96], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram892( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 892 OF 1240 ***
    // Wavefunction(s) for diagram number 892
    // (none)
    // Amplitude(s) for diagram number 892
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[2], w_fp[96], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram893( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 893 OF 1240 ***
    // Wavefunction(s) for diagram number 893
    // (none)
    // Amplitude(s) for diagram number 893
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[93], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram894( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 894 OF 1240 ***
    // Wavefunction(s) for diagram number 894
    // (none)
    // Amplitude(s) for diagram number 894
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[18], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram895( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 895 OF 1240 ***
    // Wavefunction(s) for diagram number 895
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[66], COUPs[0], 1.0, 0., 0., w_fp[65] );
    // Amplitude(s) for diagram number 895
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[13], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram896( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 896 OF 1240 ***
    // Wavefunction(s) for diagram number 896
    // (none)
    // Amplitude(s) for diagram number 896
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[11], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram897( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 897 OF 1240 ***
    // Wavefunction(s) for diagram number 897
    // (none)
    // Amplitude(s) for diagram number 897
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[6], w_fp[65], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[6], w_fp[65], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[6], w_fp[65], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram898( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 898 OF 1240 ***
    // Wavefunction(s) for diagram number 898
    // (none)
    // Amplitude(s) for diagram number 898
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[69], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram899( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 899 OF 1240 ***
    // Wavefunction(s) for diagram number 899
    // (none)
    // Amplitude(s) for diagram number 899
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[70], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram900( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 900 OF 1240 ***
    // Wavefunction(s) for diagram number 900
    // (none)
    // Amplitude(s) for diagram number 900
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[6], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[6], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[6], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram901( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 901 OF 1240 ***
    // Wavefunction(s) for diagram number 901
    // (none)
    // Amplitude(s) for diagram number 901
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[69], w_fp[11], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram902( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 902 OF 1240 ***
    // Wavefunction(s) for diagram number 902
    // (none)
    // Amplitude(s) for diagram number 902
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[70], w_fp[13], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram903( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 903 OF 1240 ***
    // Wavefunction(s) for diagram number 903
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[66], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[93] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[66], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[90] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[66], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[21] );
    // Amplitude(s) for diagram number 903
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[93], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[90], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[21], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram904( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 904 OF 1240 ***
    // Wavefunction(s) for diagram number 904
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[66], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[22] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[66], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[103] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[66], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[63] );
    // Amplitude(s) for diagram number 904
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[22], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[103], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[63], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram905( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 905 OF 1240 ***
    // Wavefunction(s) for diagram number 905
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[8], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[107] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[8], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[95] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[8], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[105] );
    // Amplitude(s) for diagram number 905
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[6], w_fp[107], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[6], w_fp[95], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[6], w_fp[105], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram906( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 906 OF 1240 ***
    // Wavefunction(s) for diagram number 906
    // (none)
    // Amplitude(s) for diagram number 906
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[118], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[119], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[4], w_fp[120], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram907( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 907 OF 1240 ***
    // Wavefunction(s) for diagram number 907
    // (none)
    // Amplitude(s) for diagram number 907
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[66], w_fp[8], w_fp[27], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[66], w_fp[8], w_fp[27], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[66], w_fp[8], w_fp[27], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram908( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 908 OF 1240 ***
    // Wavefunction(s) for diagram number 908
    // (none)
    // Amplitude(s) for diagram number 908
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[27], w_fp[65], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram909( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 909 OF 1240 ***
    // Wavefunction(s) for diagram number 909
    // (none)
    // Amplitude(s) for diagram number 909
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[27], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram910( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 910 OF 1240 ***
    // Wavefunction(s) for diagram number 910
    // (none)
    // Amplitude(s) for diagram number 910
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[8], w_fp[101], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram911( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 911 OF 1240 ***
    // Wavefunction(s) for diagram number 911
    // (none)
    // Amplitude(s) for diagram number 911
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[37], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram912( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 912 OF 1240 ***
    // Wavefunction(s) for diagram number 912
    // (none)
    // Amplitude(s) for diagram number 912
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[36], w_fp[65], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram913( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 913 OF 1240 ***
    // Wavefunction(s) for diagram number 913
    // (none)
    // Amplitude(s) for diagram number 913
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[114], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram914( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 914 OF 1240 ***
    // Wavefunction(s) for diagram number 914
    // (none)
    // Amplitude(s) for diagram number 914
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[114], w_fp[70], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram915( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 915 OF 1240 ***
    // Wavefunction(s) for diagram number 915
    // (none)
    // Amplitude(s) for diagram number 915
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[36], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram916( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 916 OF 1240 ***
    // Wavefunction(s) for diagram number 916
    // (none)
    // Amplitude(s) for diagram number 916
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[70], w_fp[37], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram917( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 917 OF 1240 ***
    // Wavefunction(s) for diagram number 917
    // (none)
    // Amplitude(s) for diagram number 917
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[22], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[103], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[63], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram918( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 918 OF 1240 ***
    // Wavefunction(s) for diagram number 918
    // (none)
    // Amplitude(s) for diagram number 918
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[33], w_fp[65], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram919( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 919 OF 1240 ***
    // Wavefunction(s) for diagram number 919
    // (none)
    // Amplitude(s) for diagram number 919
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[114], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram920( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 920 OF 1240 ***
    // Wavefunction(s) for diagram number 920
    // (none)
    // Amplitude(s) for diagram number 920
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[33], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram921( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 921 OF 1240 ***
    // Wavefunction(s) for diagram number 921
    // (none)
    // Amplitude(s) for diagram number 921
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[51], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram922( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 922 OF 1240 ***
    // Wavefunction(s) for diagram number 922
    // (none)
    // Amplitude(s) for diagram number 922
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[49], w_fp[65], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram923( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 923 OF 1240 ***
    // Wavefunction(s) for diagram number 923
    // (none)
    // Amplitude(s) for diagram number 923
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[113], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram924( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 924 OF 1240 ***
    // Wavefunction(s) for diagram number 924
    // (none)
    // Amplitude(s) for diagram number 924
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[113], w_fp[69], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram925( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 925 OF 1240 ***
    // Wavefunction(s) for diagram number 925
    // (none)
    // Amplitude(s) for diagram number 925
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[49], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram926( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 926 OF 1240 ***
    // Wavefunction(s) for diagram number 926
    // (none)
    // Amplitude(s) for diagram number 926
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[69], w_fp[51], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram927( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 927 OF 1240 ***
    // Wavefunction(s) for diagram number 927
    // (none)
    // Amplitude(s) for diagram number 927
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[93], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram928( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 928 OF 1240 ***
    // Wavefunction(s) for diagram number 928
    // (none)
    // Amplitude(s) for diagram number 928
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[47], w_fp[65], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram929( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 929 OF 1240 ***
    // Wavefunction(s) for diagram number 929
    // (none)
    // Amplitude(s) for diagram number 929
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[113], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram930( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 930 OF 1240 ***
    // Wavefunction(s) for diagram number 930
    // (none)
    // Amplitude(s) for diagram number 930
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[47], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram931( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 931 OF 1240 ***
    // Wavefunction(s) for diagram number 931
    // (none)
    // Amplitude(s) for diagram number 931
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[54], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram932( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 932 OF 1240 ***
    // Wavefunction(s) for diagram number 932
    // (none)
    // Amplitude(s) for diagram number 932
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[53], w_fp[2], w_fp[65], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram933( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 933 OF 1240 ***
    // Wavefunction(s) for diagram number 933
    // (none)
    // Amplitude(s) for diagram number 933
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[94], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram934( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 934 OF 1240 ***
    // Wavefunction(s) for diagram number 934
    // (none)
    // Amplitude(s) for diagram number 934
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[70], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram935( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 935 OF 1240 ***
    // Wavefunction(s) for diagram number 935
    // (none)
    // Amplitude(s) for diagram number 935
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[53], w_fp[94], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram936( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 936 OF 1240 ***
    // Wavefunction(s) for diagram number 936
    // (none)
    // Amplitude(s) for diagram number 936
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[70], w_fp[54], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram937( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 937 OF 1240 ***
    // Wavefunction(s) for diagram number 937
    // (none)
    // Amplitude(s) for diagram number 937
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[22], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[103], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[63], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram938( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 938 OF 1240 ***
    // Wavefunction(s) for diagram number 938
    // (none)
    // Amplitude(s) for diagram number 938
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[65], w_fp[20], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram939( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 939 OF 1240 ***
    // Wavefunction(s) for diagram number 939
    // (none)
    // Amplitude(s) for diagram number 939
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[28], w_fp[2], w_fp[65], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram940( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 940 OF 1240 ***
    // Wavefunction(s) for diagram number 940
    // (none)
    // Amplitude(s) for diagram number 940
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[94], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram941( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 941 OF 1240 ***
    // Wavefunction(s) for diagram number 941
    // (none)
    // Amplitude(s) for diagram number 941
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[2], w_fp[69], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram942( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 942 OF 1240 ***
    // Wavefunction(s) for diagram number 942
    // (none)
    // Amplitude(s) for diagram number 942
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[28], w_fp[94], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram943( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 943 OF 1240 ***
    // Wavefunction(s) for diagram number 943
    // (none)
    // Amplitude(s) for diagram number 943
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[69], w_fp[20], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram944( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 944 OF 1240 ***
    // Wavefunction(s) for diagram number 944
    // (none)
    // Amplitude(s) for diagram number 944
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[93], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram945( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 945 OF 1240 ***
    // Wavefunction(s) for diagram number 945
    // (none)
    // Amplitude(s) for diagram number 945
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[15], w_fp[65], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram946( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 946 OF 1240 ***
    // Wavefunction(s) for diagram number 946
    // (none)
    // Amplitude(s) for diagram number 946
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[2], w_fp[65], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram947( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 947 OF 1240 ***
    // Wavefunction(s) for diagram number 947
    // (none)
    // Amplitude(s) for diagram number 947
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[94], w_fp[101], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram948( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 948 OF 1240 ***
    // Wavefunction(s) for diagram number 948
    // (none)
    // Amplitude(s) for diagram number 948
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[2], w_fp[101], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram949( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 949 OF 1240 ***
    // Wavefunction(s) for diagram number 949
    // (none)
    // Amplitude(s) for diagram number 949
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[94], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram950( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 950 OF 1240 ***
    // Wavefunction(s) for diagram number 950
    // (none)
    // Amplitude(s) for diagram number 950
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[15], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram951( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 951 OF 1240 ***
    // Wavefunction(s) for diagram number 951
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[72], COUPs[0], 1.0, 0., 0., w_fp[71] );
    // Amplitude(s) for diagram number 951
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[13], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram952( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 952 OF 1240 ***
    // Wavefunction(s) for diagram number 952
    // (none)
    // Amplitude(s) for diagram number 952
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[10], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram953( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 953 OF 1240 ***
    // Wavefunction(s) for diagram number 953
    // (none)
    // Amplitude(s) for diagram number 953
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[5], w_fp[71], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[5], w_fp[71], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[5], w_fp[71], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram954( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 954 OF 1240 ***
    // Wavefunction(s) for diagram number 954
    // (none)
    // Amplitude(s) for diagram number 954
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[74], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram955( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 955 OF 1240 ***
    // Wavefunction(s) for diagram number 955
    // (none)
    // Amplitude(s) for diagram number 955
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[75], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram956( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 956 OF 1240 ***
    // Wavefunction(s) for diagram number 956
    // (none)
    // Amplitude(s) for diagram number 956
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[5], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[5], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[5], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram957( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 957 OF 1240 ***
    // Wavefunction(s) for diagram number 957
    // (none)
    // Amplitude(s) for diagram number 957
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[74], w_fp[10], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram958( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 958 OF 1240 ***
    // Wavefunction(s) for diagram number 958
    // (none)
    // Amplitude(s) for diagram number 958
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[75], w_fp[13], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram959( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 959 OF 1240 ***
    // Wavefunction(s) for diagram number 959
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[72], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[94] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[72], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[65] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[72], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[21] );
    // Amplitude(s) for diagram number 959
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[94], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[65], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[21], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram960( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 960 OF 1240 ***
    // Wavefunction(s) for diagram number 960
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[72], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[90] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[72], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[93] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[72], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[69] );
    // Amplitude(s) for diagram number 960
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[90], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[93], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[69], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram961( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 961 OF 1240 ***
    // Wavefunction(s) for diagram number 961
    // (none)
    // Amplitude(s) for diagram number 961
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[5], w_fp[107], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[5], w_fp[95], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[5], w_fp[105], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram962( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 962 OF 1240 ***
    // Wavefunction(s) for diagram number 962
    // (none)
    // Amplitude(s) for diagram number 962
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[115], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[116], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[4], w_fp[117], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram963( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 963 OF 1240 ***
    // Wavefunction(s) for diagram number 963
    // (none)
    // Amplitude(s) for diagram number 963
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[72], w_fp[8], w_fp[24], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[72], w_fp[8], w_fp[24], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[72], w_fp[8], w_fp[24], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram964( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 964 OF 1240 ***
    // Wavefunction(s) for diagram number 964
    // (none)
    // Amplitude(s) for diagram number 964
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[24], w_fp[71], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram965( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 965 OF 1240 ***
    // Wavefunction(s) for diagram number 965
    // (none)
    // Amplitude(s) for diagram number 965
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[24], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram966( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 966 OF 1240 ***
    // Wavefunction(s) for diagram number 966
    // (none)
    // Amplitude(s) for diagram number 966
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[8], w_fp[98], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram967( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 967 OF 1240 ***
    // Wavefunction(s) for diagram number 967
    // (none)
    // Amplitude(s) for diagram number 967
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[37], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram968( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 968 OF 1240 ***
    // Wavefunction(s) for diagram number 968
    // (none)
    // Amplitude(s) for diagram number 968
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[35], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram969( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 969 OF 1240 ***
    // Wavefunction(s) for diagram number 969
    // (none)
    // Amplitude(s) for diagram number 969
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[76], w_fp[114], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram970( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 970 OF 1240 ***
    // Wavefunction(s) for diagram number 970
    // (none)
    // Amplitude(s) for diagram number 970
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[114], w_fp[75], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram971( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 971 OF 1240 ***
    // Wavefunction(s) for diagram number 971
    // (none)
    // Amplitude(s) for diagram number 971
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[76], w_fp[35], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram972( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 972 OF 1240 ***
    // Wavefunction(s) for diagram number 972
    // (none)
    // Amplitude(s) for diagram number 972
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[75], w_fp[37], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram973( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 973 OF 1240 ***
    // Wavefunction(s) for diagram number 973
    // (none)
    // Amplitude(s) for diagram number 973
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[93], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[69], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram974( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 974 OF 1240 ***
    // Wavefunction(s) for diagram number 974
    // (none)
    // Amplitude(s) for diagram number 974
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[33], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram975( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 975 OF 1240 ***
    // Wavefunction(s) for diagram number 975
    // (none)
    // Amplitude(s) for diagram number 975
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[114], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram976( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 976 OF 1240 ***
    // Wavefunction(s) for diagram number 976
    // (none)
    // Amplitude(s) for diagram number 976
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[33], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram977( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 977 OF 1240 ***
    // Wavefunction(s) for diagram number 977
    // (none)
    // Amplitude(s) for diagram number 977
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[45], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram978( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 978 OF 1240 ***
    // Wavefunction(s) for diagram number 978
    // (none)
    // Amplitude(s) for diagram number 978
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[43], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram979( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 979 OF 1240 ***
    // Wavefunction(s) for diagram number 979
    // (none)
    // Amplitude(s) for diagram number 979
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[76], w_fp[102], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram980( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 980 OF 1240 ***
    // Wavefunction(s) for diagram number 980
    // (none)
    // Amplitude(s) for diagram number 980
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[102], w_fp[74], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram981( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 981 OF 1240 ***
    // Wavefunction(s) for diagram number 981
    // (none)
    // Amplitude(s) for diagram number 981
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[76], w_fp[43], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram982( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 982 OF 1240 ***
    // Wavefunction(s) for diagram number 982
    // (none)
    // Amplitude(s) for diagram number 982
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[74], w_fp[45], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram983( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 983 OF 1240 ***
    // Wavefunction(s) for diagram number 983
    // (none)
    // Amplitude(s) for diagram number 983
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[94], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[65], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram984( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 984 OF 1240 ***
    // Wavefunction(s) for diagram number 984
    // (none)
    // Amplitude(s) for diagram number 984
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[39], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram985( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 985 OF 1240 ***
    // Wavefunction(s) for diagram number 985
    // (none)
    // Amplitude(s) for diagram number 985
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[102], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram986( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 986 OF 1240 ***
    // Wavefunction(s) for diagram number 986
    // (none)
    // Amplitude(s) for diagram number 986
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[39], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram987( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 987 OF 1240 ***
    // Wavefunction(s) for diagram number 987
    // (none)
    // Amplitude(s) for diagram number 987
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[54], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram988( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 988 OF 1240 ***
    // Wavefunction(s) for diagram number 988
    // (none)
    // Amplitude(s) for diagram number 988
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[2], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram989( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 989 OF 1240 ***
    // Wavefunction(s) for diagram number 989
    // (none)
    // Amplitude(s) for diagram number 989
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[97], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram990( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 990 OF 1240 ***
    // Wavefunction(s) for diagram number 990
    // (none)
    // Amplitude(s) for diagram number 990
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[75], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram991( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 991 OF 1240 ***
    // Wavefunction(s) for diagram number 991
    // (none)
    // Amplitude(s) for diagram number 991
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[97], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram992( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 992 OF 1240 ***
    // Wavefunction(s) for diagram number 992
    // (none)
    // Amplitude(s) for diagram number 992
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[75], w_fp[54], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram993( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 993 OF 1240 ***
    // Wavefunction(s) for diagram number 993
    // (none)
    // Amplitude(s) for diagram number 993
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[90], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[93], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[69], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram994( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 994 OF 1240 ***
    // Wavefunction(s) for diagram number 994
    // (none)
    // Amplitude(s) for diagram number 994
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[23], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram995( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 995 OF 1240 ***
    // Wavefunction(s) for diagram number 995
    // (none)
    // Amplitude(s) for diagram number 995
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[25], w_fp[2], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram996( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 996 OF 1240 ***
    // Wavefunction(s) for diagram number 996
    // (none)
    // Amplitude(s) for diagram number 996
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[97], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram997( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 997 OF 1240 ***
    // Wavefunction(s) for diagram number 997
    // (none)
    // Amplitude(s) for diagram number 997
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[2], w_fp[74], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram998( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 998 OF 1240 ***
    // Wavefunction(s) for diagram number 998
    // (none)
    // Amplitude(s) for diagram number 998
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[25], w_fp[97], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram999( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
              fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
              const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
              const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
              const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
              fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
              fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 999 OF 1240 ***
    // Wavefunction(s) for diagram number 999
    // (none)
    // Amplitude(s) for diagram number 999
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[74], w_fp[23], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1000( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1000 OF 1240 ***
    // Wavefunction(s) for diagram number 1000
    // (none)
    // Amplitude(s) for diagram number 1000
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[94], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[65], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1001( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1001 OF 1240 ***
    // Wavefunction(s) for diagram number 1001
    // (none)
    // Amplitude(s) for diagram number 1001
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[17], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1002( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1002 OF 1240 ***
    // Wavefunction(s) for diagram number 1002
    // (none)
    // Amplitude(s) for diagram number 1002
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[26], w_fp[2], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1003( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1003 OF 1240 ***
    // Wavefunction(s) for diagram number 1003
    // (none)
    // Amplitude(s) for diagram number 1003
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[97], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1004( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1004 OF 1240 ***
    // Wavefunction(s) for diagram number 1004
    // (none)
    // Amplitude(s) for diagram number 1004
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[76], w_fp[2], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1005( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1005 OF 1240 ***
    // Wavefunction(s) for diagram number 1005
    // (none)
    // Amplitude(s) for diagram number 1005
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[26], w_fp[97], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1006( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1006 OF 1240 ***
    // Wavefunction(s) for diagram number 1006
    // (none)
    // Amplitude(s) for diagram number 1006
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[76], w_fp[17], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1007( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1007 OF 1240 ***
    // Wavefunction(s) for diagram number 1007
    // (none)
    // Amplitude(s) for diagram number 1007
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[59], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1008( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1008 OF 1240 ***
    // Wavefunction(s) for diagram number 1008
    // (none)
    // Amplitude(s) for diagram number 1008
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[1], w_fp[42], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1009( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1009 OF 1240 ***
    // Wavefunction(s) for diagram number 1009
    // (none)
    // Amplitude(s) for diagram number 1009
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[6], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[6], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[6], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1010( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1010 OF 1240 ***
    // Wavefunction(s) for diagram number 1010
    // (none)
    // Amplitude(s) for diagram number 1010
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[108], w_fp[6], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1011( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1011 OF 1240 ***
    // Wavefunction(s) for diagram number 1011
    // (none)
    // Amplitude(s) for diagram number 1011
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[1], w_fp[11], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1012( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1012 OF 1240 ***
    // Wavefunction(s) for diagram number 1012
    // (none)
    // Amplitude(s) for diagram number 1012
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[6], w_fp[98], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[6], w_fp[98], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[6], w_fp[98], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1013( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1013 OF 1240 ***
    // Wavefunction(s) for diagram number 1013
    // (none)
    // Amplitude(s) for diagram number 1013
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[108], w_fp[42], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1014( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1014 OF 1240 ***
    // Wavefunction(s) for diagram number 1014
    // (none)
    // Amplitude(s) for diagram number 1014
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[59], w_fp[11], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1015( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1015 OF 1240 ***
    // Wavefunction(s) for diagram number 1015
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[8], COUPs[2], 1.0, 0., 0., w_fp[11] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[8], COUPs[2], 1.0, 0., 0., w_fp[42] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[8], COUPs[2], 1.0, 0., 0., w_fp[76] );
    // Amplitude(s) for diagram number 1015
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[24], w_fp[6], w_fp[11], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[24], w_fp[6], w_fp[42], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[24], w_fp[6], w_fp[76], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1016( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1016 OF 1240 ***
    // Wavefunction(s) for diagram number 1016
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[24], COUPs[2], 1.0, 0., 0., w_fp[97] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[24], COUPs[2], 1.0, 0., 0., w_fp[71] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[24], COUPs[2], 1.0, 0., 0., w_fp[21] );
    // Amplitude(s) for diagram number 1016
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[97], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[71], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[21], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1017( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1017 OF 1240 ***
    // Wavefunction(s) for diagram number 1017
    // (none)
    // Amplitude(s) for diagram number 1017
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[118], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[119], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[24], w_fp[120], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1018( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1018 OF 1240 ***
    // Wavefunction(s) for diagram number 1018
    // (none)
    // Amplitude(s) for diagram number 1018
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[85], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[112], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[111], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1019( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1019 OF 1240 ***
    // Wavefunction(s) for diagram number 1019
    // (none)
    // Amplitude(s) for diagram number 1019
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[68], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1020( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1020 OF 1240 ***
    // Wavefunction(s) for diagram number 1020
    // (none)
    // Amplitude(s) for diagram number 1020
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[1], w_fp[16], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1021( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1021 OF 1240 ***
    // Wavefunction(s) for diagram number 1021
    // (none)
    // Amplitude(s) for diagram number 1021
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[5], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[5], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[5], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1022( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1022 OF 1240 ***
    // Wavefunction(s) for diagram number 1022
    // (none)
    // Amplitude(s) for diagram number 1022
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[101], w_fp[108], w_fp[5], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1023( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1023 OF 1240 ***
    // Wavefunction(s) for diagram number 1023
    // (none)
    // Amplitude(s) for diagram number 1023
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[101], w_fp[1], w_fp[10], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1024( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1024 OF 1240 ***
    // Wavefunction(s) for diagram number 1024
    // (none)
    // Amplitude(s) for diagram number 1024
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[5], w_fp[101], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[5], w_fp[101], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[5], w_fp[101], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1025( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1025 OF 1240 ***
    // Wavefunction(s) for diagram number 1025
    // (none)
    // Amplitude(s) for diagram number 1025
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[108], w_fp[16], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1026( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1026 OF 1240 ***
    // Wavefunction(s) for diagram number 1026
    // (none)
    // Amplitude(s) for diagram number 1026
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[68], w_fp[10], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1027( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1027 OF 1240 ***
    // Wavefunction(s) for diagram number 1027
    // (none)
    // Amplitude(s) for diagram number 1027
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[27], w_fp[5], w_fp[11], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[27], w_fp[5], w_fp[42], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[27], w_fp[5], w_fp[76], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1028( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1028 OF 1240 ***
    // Wavefunction(s) for diagram number 1028
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[27], COUPs[2], 1.0, 0., 0., w_fp[10] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[27], COUPs[2], 1.0, 0., 0., w_fp[16] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[27], COUPs[2], 1.0, 0., 0., w_fp[111] );
    // Amplitude(s) for diagram number 1028
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[10], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[16], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[111], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1029( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1029 OF 1240 ***
    // Wavefunction(s) for diagram number 1029
    // (none)
    // Amplitude(s) for diagram number 1029
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[115], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[116], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[27], w_fp[117], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1030( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1030 OF 1240 ***
    // Wavefunction(s) for diagram number 1030
    // (none)
    // Amplitude(s) for diagram number 1030
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[9], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[110], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[109], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1031( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1031 OF 1240 ***
    // Wavefunction(s) for diagram number 1031
    // (none)
    // Amplitude(s) for diagram number 1031
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[67], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1032( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1032 OF 1240 ***
    // Wavefunction(s) for diagram number 1032
    // (none)
    // Amplitude(s) for diagram number 1032
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[56], w_fp[1], w_fp[19], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1033( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1033 OF 1240 ***
    // Wavefunction(s) for diagram number 1033
    // (none)
    // Amplitude(s) for diagram number 1033
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[29], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[29], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[4], w_fp[29], w_fp[56], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1034( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1034 OF 1240 ***
    // Wavefunction(s) for diagram number 1034
    // (none)
    // Amplitude(s) for diagram number 1034
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[96], w_fp[108], w_fp[4], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1035( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1035 OF 1240 ***
    // Wavefunction(s) for diagram number 1035
    // (none)
    // Amplitude(s) for diagram number 1035
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[96], w_fp[1], w_fp[13], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1036( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1036 OF 1240 ***
    // Wavefunction(s) for diagram number 1036
    // (none)
    // Amplitude(s) for diagram number 1036
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[4], w_fp[96], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[4], w_fp[96], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[4], w_fp[96], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1037( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1037 OF 1240 ***
    // Wavefunction(s) for diagram number 1037
    // (none)
    // Amplitude(s) for diagram number 1037
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[108], w_fp[19], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1038( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1038 OF 1240 ***
    // Wavefunction(s) for diagram number 1038
    // (none)
    // Amplitude(s) for diagram number 1038
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[67], w_fp[13], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1039( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1039 OF 1240 ***
    // Wavefunction(s) for diagram number 1039
    // (none)
    // Amplitude(s) for diagram number 1039
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[4], w_fp[29], w_fp[11], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[4], w_fp[29], w_fp[42], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[4], w_fp[29], w_fp[76], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1040( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1040 OF 1240 ***
    // Wavefunction(s) for diagram number 1040
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[29], COUPs[2], 1.0, 0., 0., w_fp[76] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[29], COUPs[2], 1.0, 0., 0., w_fp[42] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[29], COUPs[2], 1.0, 0., 0., w_fp[11] );
    // Amplitude(s) for diagram number 1040
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[76], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[42], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[11], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1041( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1041 OF 1240 ***
    // Wavefunction(s) for diagram number 1041
    // (none)
    // Amplitude(s) for diagram number 1041
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[29], w_fp[107], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[29], w_fp[95], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[29], w_fp[105], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1042( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1042 OF 1240 ***
    // Wavefunction(s) for diagram number 1042
    // (none)
    // Amplitude(s) for diagram number 1042
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[87], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[34], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[86], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1043( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1043 OF 1240 ***
    // Wavefunction(s) for diagram number 1043
    // (none)
    // Amplitude(s) for diagram number 1043
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[8], w_fp[30], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[8], w_fp[30], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[8], w_fp[30], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[8], w_fp[31], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[8], w_fp[31], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[8], w_fp[31], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[8], w_fp[32], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[8], w_fp[32], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[8], w_fp[32], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1044( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1044 OF 1240 ***
    // Wavefunction(s) for diagram number 1044
    // (none)
    // Amplitude(s) for diagram number 1044
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[30], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[31], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[32], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1045( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1045 OF 1240 ***
    // Wavefunction(s) for diagram number 1045
    // (none)
    // Amplitude(s) for diagram number 1045
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[92], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[88], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[106], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1046( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1046 OF 1240 ***
    // Wavefunction(s) for diagram number 1046
    // (none)
    // Amplitude(s) for diagram number 1046
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[58], w_fp[114], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1047( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1047 OF 1240 ***
    // Wavefunction(s) for diagram number 1047
    // (none)
    // Amplitude(s) for diagram number 1047
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[114], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1048( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1048 OF 1240 ***
    // Wavefunction(s) for diagram number 1048
    // (none)
    // Amplitude(s) for diagram number 1048
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[100], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1049( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1049 OF 1240 ***
    // Wavefunction(s) for diagram number 1049
    // (none)
    // Amplitude(s) for diagram number 1049
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[36], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1050( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1050 OF 1240 ***
    // Wavefunction(s) for diagram number 1050
    // (none)
    // Amplitude(s) for diagram number 1050
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[48], w_fp[100], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1051( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1051 OF 1240 ***
    // Wavefunction(s) for diagram number 1051
    // (none)
    // Amplitude(s) for diagram number 1051
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[58], w_fp[36], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1052( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1052 OF 1240 ***
    // Wavefunction(s) for diagram number 1052
    // (none)
    // Amplitude(s) for diagram number 1052
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[114], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1053( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1053 OF 1240 ***
    // Wavefunction(s) for diagram number 1053
    // (none)
    // Amplitude(s) for diagram number 1053
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[114], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1054( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1054 OF 1240 ***
    // Wavefunction(s) for diagram number 1054
    // (none)
    // Amplitude(s) for diagram number 1054
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[100], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1055( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1055 OF 1240 ***
    // Wavefunction(s) for diagram number 1055
    // (none)
    // Amplitude(s) for diagram number 1055
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[35], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1056( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1056 OF 1240 ***
    // Wavefunction(s) for diagram number 1056
    // (none)
    // Amplitude(s) for diagram number 1056
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[40], w_fp[100], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1057( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1057 OF 1240 ***
    // Wavefunction(s) for diagram number 1057
    // (none)
    // Amplitude(s) for diagram number 1057
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[35], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1058( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1058 OF 1240 ***
    // Wavefunction(s) for diagram number 1058
    // (none)
    // Amplitude(s) for diagram number 1058
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[114], w_fp[67], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1059( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1059 OF 1240 ***
    // Wavefunction(s) for diagram number 1059
    // (none)
    // Amplitude(s) for diagram number 1059
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[114], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1060( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1060 OF 1240 ***
    // Wavefunction(s) for diagram number 1060
    // (none)
    // Amplitude(s) for diagram number 1060
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[100], w_fp[96], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1061( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1061 OF 1240 ***
    // Wavefunction(s) for diagram number 1061
    // (none)
    // Amplitude(s) for diagram number 1061
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[96], w_fp[1], w_fp[37], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1062( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1062 OF 1240 ***
    // Wavefunction(s) for diagram number 1062
    // (none)
    // Amplitude(s) for diagram number 1062
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[12], w_fp[100], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1063( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1063 OF 1240 ***
    // Wavefunction(s) for diagram number 1063
    // (none)
    // Amplitude(s) for diagram number 1063
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[67], w_fp[37], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1064( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1064 OF 1240 ***
    // Wavefunction(s) for diagram number 1064
    // (none)
    // Amplitude(s) for diagram number 1064
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[76], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[42], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[11], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1065( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1065 OF 1240 ***
    // Wavefunction(s) for diagram number 1065
    // (none)
    // Amplitude(s) for diagram number 1065
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[78], w_fp[102], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1066( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1066 OF 1240 ***
    // Wavefunction(s) for diagram number 1066
    // (none)
    // Amplitude(s) for diagram number 1066
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[53], w_fp[102], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1067( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1067 OF 1240 ***
    // Wavefunction(s) for diagram number 1067
    // (none)
    // Amplitude(s) for diagram number 1067
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[89], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1068( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1068 OF 1240 ***
    // Wavefunction(s) for diagram number 1068
    // (none)
    // Amplitude(s) for diagram number 1068
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[44], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1069( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1069 OF 1240 ***
    // Wavefunction(s) for diagram number 1069
    // (none)
    // Amplitude(s) for diagram number 1069
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[53], w_fp[89], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1070( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1070 OF 1240 ***
    // Wavefunction(s) for diagram number 1070
    // (none)
    // Amplitude(s) for diagram number 1070
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[78], w_fp[44], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1071( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1071 OF 1240 ***
    // Wavefunction(s) for diagram number 1071
    // (none)
    // Amplitude(s) for diagram number 1071
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[102], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1072( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1072 OF 1240 ***
    // Wavefunction(s) for diagram number 1072
    // (none)
    // Amplitude(s) for diagram number 1072
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[28], w_fp[102], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1073( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1073 OF 1240 ***
    // Wavefunction(s) for diagram number 1073
    // (none)
    // Amplitude(s) for diagram number 1073
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[89], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1074( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1074 OF 1240 ***
    // Wavefunction(s) for diagram number 1074
    // (none)
    // Amplitude(s) for diagram number 1074
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[43], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1075( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1075 OF 1240 ***
    // Wavefunction(s) for diagram number 1075
    // (none)
    // Amplitude(s) for diagram number 1075
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[28], w_fp[89], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1076( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1076 OF 1240 ***
    // Wavefunction(s) for diagram number 1076
    // (none)
    // Amplitude(s) for diagram number 1076
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[43], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1077( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1077 OF 1240 ***
    // Wavefunction(s) for diagram number 1077
    // (none)
    // Amplitude(s) for diagram number 1077
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[102], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1078( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1078 OF 1240 ***
    // Wavefunction(s) for diagram number 1078
    // (none)
    // Amplitude(s) for diagram number 1078
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[102], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1079( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1079 OF 1240 ***
    // Wavefunction(s) for diagram number 1079
    // (none)
    // Amplitude(s) for diagram number 1079
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[89], w_fp[101], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1080( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1080 OF 1240 ***
    // Wavefunction(s) for diagram number 1080
    // (none)
    // Amplitude(s) for diagram number 1080
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[101], w_fp[1], w_fp[45], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1081( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1081 OF 1240 ***
    // Wavefunction(s) for diagram number 1081
    // (none)
    // Amplitude(s) for diagram number 1081
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[14], w_fp[89], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1082( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1082 OF 1240 ***
    // Wavefunction(s) for diagram number 1082
    // (none)
    // Amplitude(s) for diagram number 1082
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[68], w_fp[45], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1083( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1083 OF 1240 ***
    // Wavefunction(s) for diagram number 1083
    // (none)
    // Amplitude(s) for diagram number 1083
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[10], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[111], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1084( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1084 OF 1240 ***
    // Wavefunction(s) for diagram number 1084
    // (none)
    // Amplitude(s) for diagram number 1084
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[78], w_fp[113], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1085( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1085 OF 1240 ***
    // Wavefunction(s) for diagram number 1085
    // (none)
    // Amplitude(s) for diagram number 1085
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[113], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1086( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1086 OF 1240 ***
    // Wavefunction(s) for diagram number 1086
    // (none)
    // Amplitude(s) for diagram number 1086
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[91], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1087( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1087 OF 1240 ***
    // Wavefunction(s) for diagram number 1087
    // (none)
    // Amplitude(s) for diagram number 1087
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[50], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1088( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1088 OF 1240 ***
    // Wavefunction(s) for diagram number 1088
    // (none)
    // Amplitude(s) for diagram number 1088
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[7], w_fp[91], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1089( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1089 OF 1240 ***
    // Wavefunction(s) for diagram number 1089
    // (none)
    // Amplitude(s) for diagram number 1089
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[78], w_fp[50], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1090( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1090 OF 1240 ***
    // Wavefunction(s) for diagram number 1090
    // (none)
    // Amplitude(s) for diagram number 1090
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[58], w_fp[113], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1091( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1091 OF 1240 ***
    // Wavefunction(s) for diagram number 1091
    // (none)
    // Amplitude(s) for diagram number 1091
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[25], w_fp[113], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1092( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1092 OF 1240 ***
    // Wavefunction(s) for diagram number 1092
    // (none)
    // Amplitude(s) for diagram number 1092
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[91], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1093( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1093 OF 1240 ***
    // Wavefunction(s) for diagram number 1093
    // (none)
    // Amplitude(s) for diagram number 1093
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[49], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1094( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1094 OF 1240 ***
    // Wavefunction(s) for diagram number 1094
    // (none)
    // Amplitude(s) for diagram number 1094
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[25], w_fp[91], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1095( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1095 OF 1240 ***
    // Wavefunction(s) for diagram number 1095
    // (none)
    // Amplitude(s) for diagram number 1095
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[58], w_fp[49], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1096( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1096 OF 1240 ***
    // Wavefunction(s) for diagram number 1096
    // (none)
    // Amplitude(s) for diagram number 1096
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[113], w_fp[59], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1097( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1097 OF 1240 ***
    // Wavefunction(s) for diagram number 1097
    // (none)
    // Amplitude(s) for diagram number 1097
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[26], w_fp[113], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1098( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1098 OF 1240 ***
    // Wavefunction(s) for diagram number 1098
    // (none)
    // Amplitude(s) for diagram number 1098
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[91], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1099( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1099 OF 1240 ***
    // Wavefunction(s) for diagram number 1099
    // (none)
    // Amplitude(s) for diagram number 1099
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[1], w_fp[51], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1100( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1100 OF 1240 ***
    // Wavefunction(s) for diagram number 1100
    // (none)
    // Amplitude(s) for diagram number 1100
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[26], w_fp[91], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1101( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1101 OF 1240 ***
    // Wavefunction(s) for diagram number 1101
    // (none)
    // Amplitude(s) for diagram number 1101
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[59], w_fp[51], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1102( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1102 OF 1240 ***
    // Wavefunction(s) for diagram number 1102
    // (none)
    // Amplitude(s) for diagram number 1102
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[97], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1103( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1103 OF 1240 ***
    // Wavefunction(s) for diagram number 1103
    // (none)
    // Amplitude(s) for diagram number 1103
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[67], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1104( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1104 OF 1240 ***
    // Wavefunction(s) for diagram number 1104
    // (none)
    // Amplitude(s) for diagram number 1104
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[18], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1105( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1105 OF 1240 ***
    // Wavefunction(s) for diagram number 1105
    // (none)
    // Amplitude(s) for diagram number 1105
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[78], w_fp[2], w_fp[96], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1106( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1106 OF 1240 ***
    // Wavefunction(s) for diagram number 1106
    // (none)
    // Amplitude(s) for diagram number 1106
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[96], w_fp[1], w_fp[54], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1107( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1107 OF 1240 ***
    // Wavefunction(s) for diagram number 1107
    // (none)
    // Amplitude(s) for diagram number 1107
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[78], w_fp[18], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1108( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1108 OF 1240 ***
    // Wavefunction(s) for diagram number 1108
    // (none)
    // Amplitude(s) for diagram number 1108
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[67], w_fp[54], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1109( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1109 OF 1240 ***
    // Wavefunction(s) for diagram number 1109
    // (none)
    // Amplitude(s) for diagram number 1109
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[76], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[42], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[11], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1110( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1110 OF 1240 ***
    // Wavefunction(s) for diagram number 1110
    // (none)
    // Amplitude(s) for diagram number 1110
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[2], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1111( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1111 OF 1240 ***
    // Wavefunction(s) for diagram number 1111
    // (none)
    // Amplitude(s) for diagram number 1111
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[15], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1112( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1112 OF 1240 ***
    // Wavefunction(s) for diagram number 1112
    // (none)
    // Amplitude(s) for diagram number 1112
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[58], w_fp[2], w_fp[101], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1113( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1113 OF 1240 ***
    // Wavefunction(s) for diagram number 1113
    // (none)
    // Amplitude(s) for diagram number 1113
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[101], w_fp[1], w_fp[23], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1114( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1114 OF 1240 ***
    // Wavefunction(s) for diagram number 1114
    // (none)
    // Amplitude(s) for diagram number 1114
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[58], w_fp[15], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1115( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1115 OF 1240 ***
    // Wavefunction(s) for diagram number 1115
    // (none)
    // Amplitude(s) for diagram number 1115
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[68], w_fp[23], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1116( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1116 OF 1240 ***
    // Wavefunction(s) for diagram number 1116
    // (none)
    // Amplitude(s) for diagram number 1116
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[10], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[111], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1117( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1117 OF 1240 ***
    // Wavefunction(s) for diagram number 1117
    // (none)
    // Amplitude(s) for diagram number 1117
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[2], w_fp[59], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1118( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1118 OF 1240 ***
    // Wavefunction(s) for diagram number 1118
    // (none)
    // Amplitude(s) for diagram number 1118
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[17], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1119( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1119 OF 1240 ***
    // Wavefunction(s) for diagram number 1119
    // (none)
    // Amplitude(s) for diagram number 1119
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[2], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1120( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1120 OF 1240 ***
    // Wavefunction(s) for diagram number 1120
    // (none)
    // Amplitude(s) for diagram number 1120
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[1], w_fp[20], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1121( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1121 OF 1240 ***
    // Wavefunction(s) for diagram number 1121
    // (none)
    // Amplitude(s) for diagram number 1121
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[17], w_fp[0], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1122( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1122 OF 1240 ***
    // Wavefunction(s) for diagram number 1122
    // (none)
    // Amplitude(s) for diagram number 1122
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[59], w_fp[20], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1123( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1123 OF 1240 ***
    // Wavefunction(s) for diagram number 1123
    // (none)
    // Amplitude(s) for diagram number 1123
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[97], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1124( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1124 OF 1240 ***
    // Wavefunction(s) for diagram number 1124
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[21] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[71] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[4], COUPs[2], 1.0, 0., 0., w_fp[97] );
    // Amplitude(s) for diagram number 1124
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[8], w_fp[5], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[8], w_fp[5], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[8], w_fp[5], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[8], w_fp[5], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[8], w_fp[5], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[8], w_fp[5], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[97], w_fp[8], w_fp[5], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[97], w_fp[8], w_fp[5], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[97], w_fp[8], w_fp[5], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1125( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1125 OF 1240 ***
    // Wavefunction(s) for diagram number 1125
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[21], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[59] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[71], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[20] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[97], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[60] );
    // Amplitude(s) for diagram number 1125
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[59], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[20], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[60], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1126( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1126 OF 1240 ***
    // Wavefunction(s) for diagram number 1126
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[21], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[17] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[71], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[98] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[97], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[111] );
    // Amplitude(s) for diagram number 1126
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[17], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[98], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[111], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1127( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1127 OF 1240 ***
    // Wavefunction(s) for diagram number 1127
    // (none)
    // Amplitude(s) for diagram number 1127
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[8], w_fp[29], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[8], w_fp[29], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[97], w_fp[8], w_fp[29], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1128( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1128 OF 1240 ***
    // Wavefunction(s) for diagram number 1128
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[21], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[16] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[71], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[10] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[97], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[68] );
    // Amplitude(s) for diagram number 1128
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[16], w_fp[39], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[10], w_fp[39], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[68], w_fp[39], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1129( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1129 OF 1240 ***
    // Wavefunction(s) for diagram number 1129
    // (none)
    // Amplitude(s) for diagram number 1129
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[17], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[111], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1130( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1130 OF 1240 ***
    // Wavefunction(s) for diagram number 1130
    // (none)
    // Amplitude(s) for diagram number 1130
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[39], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[39], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[39], w_fp[97], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1131( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1131 OF 1240 ***
    // Wavefunction(s) for diagram number 1131
    // (none)
    // Amplitude(s) for diagram number 1131
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[16], w_fp[47], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[10], w_fp[47], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[68], w_fp[47], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1132( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1132 OF 1240 ***
    // Wavefunction(s) for diagram number 1132
    // (none)
    // Amplitude(s) for diagram number 1132
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[59], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[20], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[60], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1133( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1133 OF 1240 ***
    // Wavefunction(s) for diagram number 1133
    // (none)
    // Amplitude(s) for diagram number 1133
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[47], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[47], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[47], w_fp[97], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1134( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1134 OF 1240 ***
    // Wavefunction(s) for diagram number 1134
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[21], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[23] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[71], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[21] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[97], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[71] );
    // Amplitude(s) for diagram number 1134
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[23], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[21], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[71], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1135( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1135 OF 1240 ***
    // Wavefunction(s) for diagram number 1135
    // (none)
    // Amplitude(s) for diagram number 1135
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[17], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[111], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1136( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1136 OF 1240 ***
    // Wavefunction(s) for diagram number 1136
    // (none)
    // Amplitude(s) for diagram number 1136
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[23], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[21], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[71], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1137( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1137 OF 1240 ***
    // Wavefunction(s) for diagram number 1137
    // (none)
    // Amplitude(s) for diagram number 1137
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[59], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[20], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[60], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1138( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1138 OF 1240 ***
    // Wavefunction(s) for diagram number 1138
    // (none)
    // Amplitude(s) for diagram number 1138
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[23], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[21], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[71], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1139( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1139 OF 1240 ***
    // Wavefunction(s) for diagram number 1139
    // (none)
    // Amplitude(s) for diagram number 1139
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[16], w_fp[2], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[10], w_fp[2], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[68], w_fp[2], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1140( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1140 OF 1240 ***
    // Wavefunction(s) for diagram number 1140
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[68] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[29] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[10] );
    // Amplitude(s) for diagram number 1140
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[68], w_fp[8], w_fp[4], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[68], w_fp[8], w_fp[4], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[68], w_fp[8], w_fp[4], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[29], w_fp[8], w_fp[4], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[29], w_fp[8], w_fp[4], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[29], w_fp[8], w_fp[4], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[10], w_fp[8], w_fp[4], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[10], w_fp[8], w_fp[4], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[10], w_fp[8], w_fp[4], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1141( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1141 OF 1240 ***
    // Wavefunction(s) for diagram number 1141
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[68], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[16] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[29], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[71] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[10], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[21] );
    // Amplitude(s) for diagram number 1141
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[16], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[71], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[21], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1142( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1142 OF 1240 ***
    // Wavefunction(s) for diagram number 1142
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[68], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[23] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[29], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[60] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[10], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[20] );
    // Amplitude(s) for diagram number 1142
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[23], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[60], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[20], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1143( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1143 OF 1240 ***
    // Wavefunction(s) for diagram number 1143
    // (none)
    // Amplitude(s) for diagram number 1143
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[68], w_fp[8], w_fp[27], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[29], w_fp[8], w_fp[27], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[10], w_fp[8], w_fp[27], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1144( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1144 OF 1240 ***
    // Wavefunction(s) for diagram number 1144
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[68], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[59] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[29], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[111] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[10], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[98] );
    // Amplitude(s) for diagram number 1144
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[59], w_fp[33], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[111], w_fp[33], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[33], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1145( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1145 OF 1240 ***
    // Wavefunction(s) for diagram number 1145
    // (none)
    // Amplitude(s) for diagram number 1145
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[23], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[60], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[20], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1146( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1146 OF 1240 ***
    // Wavefunction(s) for diagram number 1146
    // (none)
    // Amplitude(s) for diagram number 1146
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[33], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[33], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[33], w_fp[10], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1147( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1147 OF 1240 ***
    // Wavefunction(s) for diagram number 1147
    // (none)
    // Amplitude(s) for diagram number 1147
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[59], w_fp[47], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[111], w_fp[47], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[47], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1148( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1148 OF 1240 ***
    // Wavefunction(s) for diagram number 1148
    // (none)
    // Amplitude(s) for diagram number 1148
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1149( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1149 OF 1240 ***
    // Wavefunction(s) for diagram number 1149
    // (none)
    // Amplitude(s) for diagram number 1149
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[47], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[47], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[47], w_fp[10], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1150( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1150 OF 1240 ***
    // Wavefunction(s) for diagram number 1150
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[68], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[17] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[29], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[68] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[10], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[29] );
    // Amplitude(s) for diagram number 1150
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[17], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[68], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[29], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1151( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1151 OF 1240 ***
    // Wavefunction(s) for diagram number 1151
    // (none)
    // Amplitude(s) for diagram number 1151
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[23], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[60], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[20], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1152( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1152 OF 1240 ***
    // Wavefunction(s) for diagram number 1152
    // (none)
    // Amplitude(s) for diagram number 1152
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[17], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[68], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[29], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1153( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1153 OF 1240 ***
    // Wavefunction(s) for diagram number 1153
    // (none)
    // Amplitude(s) for diagram number 1153
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1154( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1154 OF 1240 ***
    // Wavefunction(s) for diagram number 1154
    // (none)
    // Amplitude(s) for diagram number 1154
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[17], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[68], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[29], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1155( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1155 OF 1240 ***
    // Wavefunction(s) for diagram number 1155
    // (none)
    // Amplitude(s) for diagram number 1155
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[59], w_fp[2], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[111], w_fp[2], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[2], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1156( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1156 OF 1240 ***
    // Wavefunction(s) for diagram number 1156
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[98] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[27] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[1], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[111] );
    // Amplitude(s) for diagram number 1156
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[8], w_fp[4], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[8], w_fp[4], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[8], w_fp[4], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[27], w_fp[8], w_fp[4], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[27], w_fp[8], w_fp[4], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[27], w_fp[8], w_fp[4], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[111], w_fp[8], w_fp[4], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[111], w_fp[8], w_fp[4], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[111], w_fp[8], w_fp[4], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1157( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1157 OF 1240 ***
    // Wavefunction(s) for diagram number 1157
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[98], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[59] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[27], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[29] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[111], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[68] );
    // Amplitude(s) for diagram number 1157
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[59], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[29], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[68], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1158( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1158 OF 1240 ***
    // Wavefunction(s) for diagram number 1158
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[98], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[17] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[27], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[21] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[111], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[71] );
    // Amplitude(s) for diagram number 1158
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[17], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[21], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[71], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1159( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1159 OF 1240 ***
    // Wavefunction(s) for diagram number 1159
    // (none)
    // Amplitude(s) for diagram number 1159
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[8], w_fp[24], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[27], w_fp[8], w_fp[24], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[111], w_fp[8], w_fp[24], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1160( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1160 OF 1240 ***
    // Wavefunction(s) for diagram number 1160
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[98], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[16] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[27], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[20] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[111], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[60] );
    // Amplitude(s) for diagram number 1160
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[16], w_fp[33], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[20], w_fp[33], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[33], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1161( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1161 OF 1240 ***
    // Wavefunction(s) for diagram number 1161
    // (none)
    // Amplitude(s) for diagram number 1161
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[17], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1162( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1162 OF 1240 ***
    // Wavefunction(s) for diagram number 1162
    // (none)
    // Amplitude(s) for diagram number 1162
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[33], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[33], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[33], w_fp[111], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1163( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1163 OF 1240 ***
    // Wavefunction(s) for diagram number 1163
    // (none)
    // Amplitude(s) for diagram number 1163
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[16], w_fp[39], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[20], w_fp[39], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[39], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1164( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1164 OF 1240 ***
    // Wavefunction(s) for diagram number 1164
    // (none)
    // Amplitude(s) for diagram number 1164
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[59], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1165( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1165 OF 1240 ***
    // Wavefunction(s) for diagram number 1165
    // (none)
    // Amplitude(s) for diagram number 1165
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[39], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[39], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[39], w_fp[111], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1166( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1166 OF 1240 ***
    // Wavefunction(s) for diagram number 1166
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[98], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[23] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[27], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[98] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[111], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[27] );
    // Amplitude(s) for diagram number 1166
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[23], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[98], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[27], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1167( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1167 OF 1240 ***
    // Wavefunction(s) for diagram number 1167
    // (none)
    // Amplitude(s) for diagram number 1167
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[17], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1168( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1168 OF 1240 ***
    // Wavefunction(s) for diagram number 1168
    // (none)
    // Amplitude(s) for diagram number 1168
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[23], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[98], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[27], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1169( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1169 OF 1240 ***
    // Wavefunction(s) for diagram number 1169
    // (none)
    // Amplitude(s) for diagram number 1169
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[59], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1170( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1170 OF 1240 ***
    // Wavefunction(s) for diagram number 1170
    // (none)
    // Amplitude(s) for diagram number 1170
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[23], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[98], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[27], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1171( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1171 OF 1240 ***
    // Wavefunction(s) for diagram number 1171
    // (none)
    // Amplitude(s) for diagram number 1171
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[16], w_fp[2], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[20], w_fp[2], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[2], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1172( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1172 OF 1240 ***
    // Wavefunction(s) for diagram number 1172
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[4], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[60] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[4], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[24] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[4], w_fp[5], COUPs[2], 1.0, 0., 0., w_fp[20] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[60], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[16] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[24], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[27] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[20], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[98] );
    // Amplitude(s) for diagram number 1172
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[16], w_fp[77], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[27], w_fp[77], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[77], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1173( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1173 OF 1240 ***
    // Wavefunction(s) for diagram number 1173
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[60], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[23] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[24], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[68] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[20], w_fp[6], COUPs[0], 1.0, 0., 0., w_fp[29] );
    // Amplitude(s) for diagram number 1173
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[23], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1174( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1174 OF 1240 ***
    // Wavefunction(s) for diagram number 1174
    // (none)
    // Amplitude(s) for diagram number 1174
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[77], w_fp[60], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[77], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[77], w_fp[20], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1175( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1175 OF 1240 ***
    // Wavefunction(s) for diagram number 1175
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[60], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[59] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[24], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[71] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[20], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[21] );
    // Amplitude(s) for diagram number 1175
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[59], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[71], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[21], w_fp[6], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1176( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1176 OF 1240 ***
    // Wavefunction(s) for diagram number 1176
    // (none)
    // Amplitude(s) for diagram number 1176
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[23], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1177( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1177 OF 1240 ***
    // Wavefunction(s) for diagram number 1177
    // (none)
    // Amplitude(s) for diagram number 1177
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[47], w_fp[60], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[47], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[47], w_fp[20], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1178( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1178 OF 1240 ***
    // Wavefunction(s) for diagram number 1178
    // (none)
    // Amplitude(s) for diagram number 1178
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[59], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[71], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[21], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1179( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1179 OF 1240 ***
    // Wavefunction(s) for diagram number 1179
    // (none)
    // Amplitude(s) for diagram number 1179
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[16], w_fp[2], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[27], w_fp[2], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[2], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1180( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1180 OF 1240 ***
    // Wavefunction(s) for diagram number 1180
    // (none)
    // Amplitude(s) for diagram number 1180
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[72], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[24], w_fp[72], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[20], w_fp[72], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1181( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1181 OF 1240 ***
    // Wavefunction(s) for diagram number 1181
    // (none)
    // Amplitude(s) for diagram number 1181
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[1], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[1], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[1], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[24], w_fp[1], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[24], w_fp[1], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[24], w_fp[1], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[20], w_fp[1], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[20], w_fp[1], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[20], w_fp[1], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1182( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1182 OF 1240 ***
    // Wavefunction(s) for diagram number 1182
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[60], w_fp[1], COUPs[0], 1.0, 0., 0., w_fp[72] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[24], w_fp[1], COUPs[0], 1.0, 0., 0., w_fp[60] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[20], w_fp[1], COUPs[0], 1.0, 0., 0., w_fp[24] );
    // Amplitude(s) for diagram number 1182
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[72], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[60], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[24], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1183( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1183 OF 1240 ***
    // Wavefunction(s) for diagram number 1183
    // (none)
    // Amplitude(s) for diagram number 1183
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[23], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[68], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[29], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1184( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1184 OF 1240 ***
    // Wavefunction(s) for diagram number 1184
    // (none)
    // Amplitude(s) for diagram number 1184
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[60], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 112 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 118 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1185( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1185 OF 1240 ***
    // Wavefunction(s) for diagram number 1185
    // (none)
    // Amplitude(s) for diagram number 1185
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[16], w_fp[47], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 102 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[27], w_fp[47], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 103 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[98], w_fp[47], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 102 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1186( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1186 OF 1240 ***
    // Wavefunction(s) for diagram number 1186
    // (none)
    // Amplitude(s) for diagram number 1186
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[60], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 26 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 24 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1187( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1187 OF 1240 ***
    // Wavefunction(s) for diagram number 1187
    // (none)
    // Amplitude(s) for diagram number 1187
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[59], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[71], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 60 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[21], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 84 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1188( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1188 OF 1240 ***
    // Wavefunction(s) for diagram number 1188
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[4], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[21] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[4], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[71] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[4], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[59] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[21], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[24] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[71], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[60] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[59], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[72] );
    // Amplitude(s) for diagram number 1188
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[24], w_fp[77], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[77], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[77], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1189( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1189 OF 1240 ***
    // Wavefunction(s) for diagram number 1189
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[21], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[98] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[71], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[27] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[59], w_fp[5], COUPs[0], 1.0, 0., 0., w_fp[16] );
    // Amplitude(s) for diagram number 1189
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1190( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1190 OF 1240 ***
    // Wavefunction(s) for diagram number 1190
    // (none)
    // Amplitude(s) for diagram number 1190
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[77], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[77], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[77], w_fp[59], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1191( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1191 OF 1240 ***
    // Wavefunction(s) for diagram number 1191
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[21], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[29] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[71], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[68] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[59], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[23] );
    // Amplitude(s) for diagram number 1191
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[29], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[68], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[23], w_fp[5], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1192( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1192 OF 1240 ***
    // Wavefunction(s) for diagram number 1192
    // (none)
    // Amplitude(s) for diagram number 1192
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[98], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1193( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1193 OF 1240 ***
    // Wavefunction(s) for diagram number 1193
    // (none)
    // Amplitude(s) for diagram number 1193
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[39], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[39], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[39], w_fp[59], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1194( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1194 OF 1240 ***
    // Wavefunction(s) for diagram number 1194
    // (none)
    // Amplitude(s) for diagram number 1194
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[29], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[68], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[23], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1195( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1195 OF 1240 ***
    // Wavefunction(s) for diagram number 1195
    // (none)
    // Amplitude(s) for diagram number 1195
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[24], w_fp[2], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[2], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[2], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1196( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1196 OF 1240 ***
    // Wavefunction(s) for diagram number 1196
    // (none)
    // Amplitude(s) for diagram number 1196
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[66], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[66], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[59], w_fp[66], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1197( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1197 OF 1240 ***
    // Wavefunction(s) for diagram number 1197
    // (none)
    // Amplitude(s) for diagram number 1197
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[1], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[1], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[1], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[1], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[1], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[1], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[59], w_fp[1], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[59], w_fp[1], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[59], w_fp[1], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1198( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1198 OF 1240 ***
    // Wavefunction(s) for diagram number 1198
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[21], w_fp[1], COUPs[0], 1.0, 0., 0., w_fp[66] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[71], w_fp[1], COUPs[0], 1.0, 0., 0., w_fp[21] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[59], w_fp[1], COUPs[0], 1.0, 0., 0., w_fp[71] );
    // Amplitude(s) for diagram number 1198
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[66], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[21], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[71], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1199( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1199 OF 1240 ***
    // Wavefunction(s) for diagram number 1199
    // (none)
    // Amplitude(s) for diagram number 1199
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[98], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[27], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[16], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 36 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 109 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1200( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1200 OF 1240 ***
    // Wavefunction(s) for diagram number 1200
    // (none)
    // Amplitude(s) for diagram number 1200
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 88 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 85 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 94 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1201( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1201 OF 1240 ***
    // Wavefunction(s) for diagram number 1201
    // (none)
    // Amplitude(s) for diagram number 1201
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[24], w_fp[39], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 78 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[60], w_fp[39], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 79 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[72], w_fp[39], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 78 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1202( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1202 OF 1240 ***
    // Wavefunction(s) for diagram number 1202
    // (none)
    // Amplitude(s) for diagram number 1202
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[66], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[21], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 28 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[71], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 25 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 42 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1203( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1203 OF 1240 ***
    // Wavefunction(s) for diagram number 1203
    // (none)
    // Amplitude(s) for diagram number 1203
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[29], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[68], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 66 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[23], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 108 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1204( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1204 OF 1240 ***
    // Wavefunction(s) for diagram number 1204
    VVVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[23] );
    VVVV3P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[68] );
    VVVV4P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[5], w_fp[6], COUPs[2], 1.0, 0., 0., w_fp[29] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[23], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[71] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[68], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[21] );
    FFV1_2<W_ACCESS, CD_ACCESS>( w_fp[3], w_fp[29], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[66] );
    // Amplitude(s) for diagram number 1204
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[77], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[77], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[77], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1205( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1205 OF 1240 ***
    // Wavefunction(s) for diagram number 1205
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[23], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[72] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[68], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[60] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[29], w_fp[4], COUPs[0], 1.0, 0., 0., w_fp[24] );
    // Amplitude(s) for diagram number 1205
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[60], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1206( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1206 OF 1240 ***
    // Wavefunction(s) for diagram number 1206
    // (none)
    // Amplitude(s) for diagram number 1206
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[77], w_fp[23], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[77], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[77], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1207( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1207 OF 1240 ***
    // Wavefunction(s) for diagram number 1207
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[23], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[77] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[68], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[16] );
    FFV1_1<W_ACCESS, CD_ACCESS>( w_fp[2], w_fp[29], COUPs[1], 1.0, cIPD[0], cIPD[1], w_fp[27] );
    // Amplitude(s) for diagram number 1207
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[77], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[16], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[27], w_fp[4], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1208( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1208 OF 1240 ***
    // Wavefunction(s) for diagram number 1208
    // (none)
    // Amplitude(s) for diagram number 1208
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[72], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[60], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[2], w_fp[24], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1209( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1209 OF 1240 ***
    // Wavefunction(s) for diagram number 1209
    // (none)
    // Amplitude(s) for diagram number 1209
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[33], w_fp[23], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[33], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[52], w_fp[33], w_fp[29], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1210( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1210 OF 1240 ***
    // Wavefunction(s) for diagram number 1210
    // (none)
    // Amplitude(s) for diagram number 1210
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[77], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[16], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[27], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1211( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1211 OF 1240 ***
    // Wavefunction(s) for diagram number 1211
    // (none)
    // Amplitude(s) for diagram number 1211
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[2], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[2], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[2], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1212( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1212 OF 1240 ***
    // Wavefunction(s) for diagram number 1212
    // (none)
    // Amplitude(s) for diagram number 1212
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[23], w_fp[61], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[68], w_fp[61], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[29], w_fp[61], w_fp[8], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1213( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1213 OF 1240 ***
    // Wavefunction(s) for diagram number 1213
    // (none)
    // Amplitude(s) for diagram number 1213
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[23], w_fp[1], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[23], w_fp[1], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[23], w_fp[1], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[68], w_fp[1], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[68], w_fp[1], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[68], w_fp[1], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[29], w_fp[1], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[29], w_fp[1], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[29], w_fp[1], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1214( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1214 OF 1240 ***
    // Wavefunction(s) for diagram number 1214
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[23], w_fp[1], COUPs[0], 1.0, 0., 0., w_fp[61] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[68], w_fp[1], COUPs[0], 1.0, 0., 0., w_fp[23] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[29], w_fp[1], COUPs[0], 1.0, 0., 0., w_fp[68] );
    // Amplitude(s) for diagram number 1214
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[61], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[23], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[68], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1215( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1215 OF 1240 ***
    // Wavefunction(s) for diagram number 1215
    // (none)
    // Amplitude(s) for diagram number 1215
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[72], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[60], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 31 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 91 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[1], w_fp[8], w_fp[24], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 30 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 115 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1216( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1216 OF 1240 ***
    // Wavefunction(s) for diagram number 1216
    // (none)
    // Amplitude(s) for diagram number 1216
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[23], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 64 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 61 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 67 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 70 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1217( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1217 OF 1240 ***
    // Wavefunction(s) for diagram number 1217
    // (none)
    // Amplitude(s) for diagram number 1217
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[71], w_fp[33], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 54 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[21], w_fp[33], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 55 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[66], w_fp[33], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 54 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1218( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1218 OF 1240 ***
    // Wavefunction(s) for diagram number 1218
    // (none)
    // Amplitude(s) for diagram number 1218
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[61], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[23], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 29 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[68], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 27 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 37 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 43 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1219( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1219 OF 1240 ***
    // Wavefunction(s) for diagram number 1219
    // (none)
    // Amplitude(s) for diagram number 1219
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[77], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[16], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 90 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[27], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 114 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1220( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1220 OF 1240 ***
    // Wavefunction(s) for diagram number 1220
    // (none)
    // Amplitude(s) for diagram number 1220
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[73], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[73], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[73], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[79], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[79], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[79], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[80], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[80], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[80], w_fp[8], w_fp[6], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1221( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1221 OF 1240 ***
    // Wavefunction(s) for diagram number 1221
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[73], COUPs[0], 1.0, 0., 0., w_fp[27] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[79], COUPs[0], 1.0, 0., 0., w_fp[1] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[80], COUPs[0], 1.0, 0., 0., w_fp[16] );
    // Amplitude(s) for diagram number 1221
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[27], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[1], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[6], w_fp[16], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1222( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1222 OF 1240 ***
    // Wavefunction(s) for diagram number 1222
    // (none)
    // Amplitude(s) for diagram number 1222
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[73], w_fp[6], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[79], w_fp[6], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 21 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 39 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[80], w_fp[6], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 23 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 33 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1223( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1223 OF 1240 ***
    // Wavefunction(s) for diagram number 1223
    // (none)
    // Amplitude(s) for diagram number 1223
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 113 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[47], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 119 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1224( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1224 OF 1240 ***
    // Wavefunction(s) for diagram number 1224
    // (none)
    // Amplitude(s) for diagram number 1224
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[113], w_fp[73], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[113], w_fp[79], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 97 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 99 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[113], w_fp[80], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 96 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 98 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 100 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 101 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1225( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1225 OF 1240 ***
    // Wavefunction(s) for diagram number 1225
    // (none)
    // Amplitude(s) for diagram number 1225
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[27], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[1], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 2 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[41], w_fp[2], w_fp[16], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 0 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1226( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1226 OF 1240 ***
    // Wavefunction(s) for diagram number 1226
    // (none)
    // Amplitude(s) for diagram number 1226
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[2], w_fp[73], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 32 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[2], w_fp[79], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 38 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 62 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[62], w_fp[2], w_fp[80], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 32 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 56 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 80 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 86 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1227( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1227 OF 1240 ***
    // Wavefunction(s) for diagram number 1227
    // (none)
    // Amplitude(s) for diagram number 1227
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[57], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[57], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[57], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[81], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[81], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[81], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[82], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[82], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[82], w_fp[8], w_fp[5], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1228( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1228 OF 1240 ***
    // Wavefunction(s) for diagram number 1228
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[57], COUPs[0], 1.0, 0., 0., w_fp[62] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[81], COUPs[0], 1.0, 0., 0., w_fp[80] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[82], COUPs[0], 1.0, 0., 0., w_fp[79] );
    // Amplitude(s) for diagram number 1228
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[62], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[80], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[5], w_fp[79], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1229( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1229 OF 1240 ***
    // Wavefunction(s) for diagram number 1229
    // (none)
    // Amplitude(s) for diagram number 1229
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[57], w_fp[5], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[81], w_fp[5], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 15 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 45 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[82], w_fp[5], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 12 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 14 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 17 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 35 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 105 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 111 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1230( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1230 OF 1240 ***
    // Wavefunction(s) for diagram number 1230
    // (none)
    // Amplitude(s) for diagram number 1230
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[62], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[80], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 89 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[39], w_fp[79], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 81 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 87 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 95 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1231( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1231 OF 1240 ***
    // Wavefunction(s) for diagram number 1231
    // (none)
    // Amplitude(s) for diagram number 1231
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[102], w_fp[57], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[102], w_fp[81], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 73 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 75 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[102], w_fp[82], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 72 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 74 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 76 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 77 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1232( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1232 OF 1240 ***
    // Wavefunction(s) for diagram number 1232
    // (none)
    // Amplitude(s) for diagram number 1232
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[62], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[80], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 4 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[38], w_fp[2], w_fp[79], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 1 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 18 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 20 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1233( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1233 OF 1240 ***
    // Wavefunction(s) for diagram number 1233
    // (none)
    // Amplitude(s) for diagram number 1233
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[2], w_fp[57], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 34 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[2], w_fp[81], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 44 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 68 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[104], w_fp[2], w_fp[82], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 34 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 58 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 104 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 110 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1234( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1234 OF 1240 ***
    // Wavefunction(s) for diagram number 1234
    // (none)
    // Amplitude(s) for diagram number 1234
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[55], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[55], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[55], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[83], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[83], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[83], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    VVVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[84], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    VVVV3_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[84], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
    VVVV4_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[0], w_fp[84], w_fp[8], w_fp[4], COUPs[2], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1235( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1235 OF 1240 ***
    // Wavefunction(s) for diagram number 1235
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[55], COUPs[0], 1.0, 0., 0., w_fp[104] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[83], COUPs[0], 1.0, 0., 0., w_fp[82] );
    VVV1P0_1<W_ACCESS, CD_ACCESS>( w_fp[0], w_fp[84], COUPs[0], 1.0, 0., 0., w_fp[81] );
    // Amplitude(s) for diagram number 1235
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[104], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[82], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[8], w_fp[4], w_fp[81], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1236( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1236 OF 1240 ***
    // Wavefunction(s) for diagram number 1236
    // (none)
    // Amplitude(s) for diagram number 1236
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[55], w_fp[4], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[83], w_fp[4], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 7 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 9 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 47 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 93 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    VVV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[84], w_fp[4], w_fp[56], COUPs[0], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 6 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 8 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 10 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 11 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 41 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 83 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 107 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 117 ) += amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1237( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1237 OF 1240 ***
    // Wavefunction(s) for diagram number 1237
    // (none)
    // Amplitude(s) for diagram number 1237
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[82], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 59 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 65 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[33], w_fp[81], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 57 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 63 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 69 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 71 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1238( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1238 OF 1240 ***
    // Wavefunction(s) for diagram number 1238
    // (none)
    // Amplitude(s) for diagram number 1238
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[114], w_fp[55], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[114], w_fp[83], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 49 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 51 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[3], w_fp[114], w_fp[84], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 48 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 50 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 52 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 53 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1239( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1239 OF 1240 ***
    // Wavefunction(s) for diagram number 1239
    // (none)
    // Amplitude(s) for diagram number 1239
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[104], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[82], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 5 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 16 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[46], w_fp[2], w_fp[81], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 3 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 13 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 19 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 22 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += cxtype( 0, 1 ) * amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= cxtype( 0, 1 ) * amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

  __global__ void
  diagram1240( fptype* wfs,                    // input/output wavefunctions[nwf*2*nw6*nevtORneppV]
               fptype* jamps,                  // output jamps[ncolor*2*nevtORneppV]
               const unsigned int* channelIds, // input: channelIds[nevt] for GPU or SCALAR channelId[0] for C++ (1 to #diagrams, 0 to disable SDE)
#ifdef MGONGPUCPP_GPUIMPL
               const fptype* couplings,        // input: dependent couplings[nevt*ndcoup*2] for all events
#else
               const fptype** COUPs,           // input: dependent and independent COUPs[nxcoup] for this event page
#endif
               fptype* numerators,             // input/output: multichannel numerators[nevtORneppV], add helicity ihel
               fptype* denominators )          // input/output: multichannel denominators[nevtORneppV], add helicity ihel
  {
    // A uniform interface for diagramXXX including channelIDs, numerators and denominators is used also #ifndef MGONGPU_SUPPORTS_MULTICHANNEL
    // In that case, however, the boilerplate code asserts that all three pointers all nullptr as a sanity check
#include "diagram_boilerplate.h"
    // *** DIAGRAM 1240 OF 1240 ***
    // Wavefunction(s) for diagram number 1240
    // (none)
    // Amplitude(s) for diagram number 1240
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[55], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 40 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[83], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 46 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 92 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    FFV1_0<W_ACCESS, A_ACCESS, CD_ACCESS>( w_fp[99], w_fp[2], w_fp[84], COUPs[1], 1.0, &amp_fp[0] );
#ifdef MGONGPU_SUPPORTS_MULTICHANNEL
    // Here the code base generated with multichannel support updates numerators_sv and denominators_sv (#473)
#endif
    J_ACCESS::kernelAccessIcol( jamps, 40 ) -= amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 82 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 106 ) += amp_sv[0];
    J_ACCESS::kernelAccessIcol( jamps, 116 ) -= amp_sv[0];
  }
  
  //--------------------------------------------------------------------------

/* clang-format on */
