diff --git b/epochX/cudacpp/gg_tt.mad/Source/dsample.f a/epochX/cudacpp/gg_tt.mad/Source/dsample.f
index e18ba7c03..35e52cf44 100644
--- b/epochX/cudacpp/gg_tt.mad/Source/dsample.f
+++ a/epochX/cudacpp/gg_tt.mad/Source/dsample.f
@@ -169,7 +169,9 @@ c
          if (iter .le. itmax) then
 c            write(*,*) 'iter/ievent/ivec', iter, ievent, ivec
             ievent=ievent+1
+            CALL COUNTERS_START_COUNTER( 3, 1 ) ! FortranRandom2Momenta=3
             call x_to_f_arg(ndim,ipole,mincfig,maxcfig,ninvar,wgt,x,p)
+            CALL COUNTERS_STOP_COUNTER( 3 ) ! FortranRandom2Momenta=3
             CUTSDONE=.FALSE.
             CUTSPASSED=.FALSE.
             if (passcuts(p,VECSIZE_USED)) then
@@ -223,6 +225,7 @@ c     write(*,*) i, all_wgt(i), fx, all_wgt(i)*fx
                do I=1, VECSIZE_USED
                   all_wgt(i) = all_wgt(i)*all_fx(i)
               enddo
+               CALL COUNTERS_START_COUNTER( 8, VECSIZE_USED ) ! FortranSamplePutPoint=8
                do i =1, VECSIZE_USED
 c     if last paremeter is true -> allow grid update so only for a full page
                   lastbin(:) = all_lastbin(:,i)
@@ -230,6 +233,7 @@ c     if last paremeter is true -> allow grid update so only for a full page
 c                  write(*,*) 'put point in sample kevent', kevent, 'allow_update', ivec.eq.VECSIZE_USED                   
                   call sample_put_point(all_wgt(i),all_x(1,i),iter,ipole, i.eq.VECSIZE_USED) !Store result
                enddo
+               CALL COUNTERS_STOP_COUNTER( 8 ) ! FortranSamplePutPoint=8
                if (VECSIZE_USED.ne.1.and.force_reset)then
                   call reset_cumulative_variable()
                   force_reset=.false.
@@ -240,7 +244,9 @@ c     if (wgt .ne. 0d0) call graph_point(p,wgt) !Update graphs
             else
                fx =0d0
                wgt=0d0
+               CALL COUNTERS_START_COUNTER( 8, 1 ) ! FortranSamplePutPoint=8
                call sample_put_point(wgt,x(1),iter,ipole,.true.) !Store result
+               CALL COUNTERS_STOP_COUNTER( 8 ) ! FortranSamplePutPoint=8
             endif
 
          endif
@@ -405,7 +411,9 @@ c
          call sample_get_config(wgt,iter,ipole)
          if (iter .le. itmax) then
             ievent=ievent+1
+            CALL COUNTERS_START_COUNTER( 3, 1 ) ! FortranRandom2Momenta=3
             call x_to_f_arg(ndim,ipole,mincfig,maxcfig,ninvar,wgt,x,p)
+            CALL COUNTERS_STOP_COUNTER( 3 ) ! FortranRandom2Momenta=3
             if (pass_point(p)) then
                xzoomfact = 1d0
                fx = dsig(p,wgt,0) !Evaluate function
@@ -421,7 +429,9 @@ c
             endif
             
             if (nzoom .le. 0) then
+               CALL COUNTERS_START_COUNTER( 8, 1 ) ! FortranSamplePutPoint=8
                call sample_put_point(wgt,x(1),iter,ipole,.true.) !Store result
+               CALL COUNTERS_STOP_COUNTER( 8 ) ! FortranSamplePutPoint=8
             else
                nzoom = nzoom -1
                ievent=ievent-1
@@ -727,7 +737,7 @@ c
       common/read_grid_file/read_grid_file
 
       data use_cut/2/            !Grid: 0=fixed , 1=standard, 2=non-zero
-      data ituple/1/             !1=htuple, 2=sobel 
+      data ituple/1/             !1=ntuple(ranmar or htuple), 2=sobel 
       data Minvar(1,1)/-1/       !No special variable mapping
 
 c-----
@@ -1240,7 +1250,20 @@ c
 c     Local
 c
       integer  im, ip,ij,icount,it_warned
-      double precision xbin_min,xbin_max,ddum(maxdim),xo,y
+      double precision xbin_min,xbin_max,ddum(maxdim),xo,y 
+c
+c     Local (performance optimization #969)
+c
+      integer xbinarraydim
+      parameter (xbinarraydim=maxdim*lmaxconfigs)
+      double precision xbin_min0_array(maxdim, lmaxconfigs)
+      double precision xbin_max1_array(maxdim, lmaxconfigs)
+      logical xbin_min0_saved(maxdim, lmaxconfigs)
+      logical xbin_max1_saved(maxdim, lmaxconfigs)
+      save xbin_min0_array, xbin_max1_array
+      save xbin_min0_saved, xbin_max1_saved
+      data xbin_min0_saved/xbinarraydim*.false./
+      data xbin_max1_saved/xbinarraydim*.false./
 c
 c     External
 c
@@ -1291,15 +1314,29 @@ c         write(*,'(7f11.5)')(ddum(j)*real(ng),j=1,dim)
       endif
       if (ituple .eq. 1) then
 c         write(*,*) 'Getting variable',ipole,j,minvar(j,ipole)
-         xbin_min = xbin(xmin,minvar(j,ipole))
-         xbin_max = xbin(xmax,minvar(j,ipole))
-         if (xbin_min .gt. xbin_max-1) then
-c            write(*,'(a,4e15.4)') 'Bad limits',xbin_min,xbin_max,
-c     &           xmin,xmax
-c            xbin_max=xbin_min+1d-10
-            xbin_max = xbin(xmax,minvar(j,ipole))
-            xbin_min = min(xbin(xmin,minvar(j,ipole)), xbin_max)
-         endif
+
+        if(xmax.ne.1 .or. .not.xbin_max1_saved(j,ipole)) then
+          xbin_max = xbin(xmax, minvar(j,ipole))
+          if(xmax.eq.1) then
+            xbin_max1_array(j,ipole) = xbin_max
+            xbin_max1_saved(j,ipole) = .true.
+          endif
+        else
+          xbin_max = xbin_max1_array(j,ipole)
+        endif
+
+        if(xmin.ne.0 .or. .not.xbin_min0_saved(j,ipole)) then
+          xbin_min = xbin(xmin, minvar(j,ipole))
+          if (xbin_min .gt. xbin_max-1) then
+            xbin_min = min(xbin_min, xbin_max)
+          endif
+          if(xmin.eq.0) then
+            xbin_min0_array(j,ipole) = xbin_min
+            xbin_min0_saved(j,ipole) = .true.
+          endif
+        else
+          xbin_min = xbin_min0_array(j,ipole)
+        endif
 c
 c     Line which allows us to keep choosing same x
 c
@@ -1312,10 +1349,10 @@ c            write(*,*) 'Reusing num',j,nzoom,tx(2,j)
             call ntuple(ddum(j),max(xbin_min,dble(int(tx(2,j)))),
      $           min(xbin_max,dble(int(tx(2,j))+1)),j,ipole)
 
-            if(max(xbin_min,dble(int(tx(2,j)))).gt.
-     $           min(xbin_max,dble(int(tx(2,j))+1))) then
+c           if(max(xbin_min,dble(int(tx(2,j)))).gt.
+c    $           min(xbin_max,dble(int(tx(2,j))+1))) then
 c               write(*,*) 'not good'
-            endif
+c           endif
 
 c            write(*,'(2i6,4e15.5)') nzoom,j,ddum(j),tx(2,j),
 c     $           max(xbin_min,dble(int(tx(2,j)))),
@@ -1389,10 +1426,10 @@ c
          endif
          icount=icount+1
       endif
-      if (x .lt. xmin .or. x .gt. xmax) then
+c     if (x .lt. xmin .or. x .gt. xmax) then
 c         write(*,'(a,4i4,2f24.16,1e10.2)') 'Bad x',ij,int(xbin_min),ip,
 c     &        int(xbin_max),xmin,x,xmax-xmin
-      endif
+c     endif
 
       wgt = wgt * xo * dble(xbin_max-xbin_min)
 c      print*,'Returning x',ij,ipole,j,x
diff --git b/epochX/cudacpp/gg_tt.mad/Source/genps.inc a/epochX/cudacpp/gg_tt.mad/Source/genps.inc
index a59181c70..af7e0efbc 100644
--- b/epochX/cudacpp/gg_tt.mad/Source/genps.inc
+++ a/epochX/cudacpp/gg_tt.mad/Source/genps.inc
@@ -30,7 +30,8 @@ c*************************************************************************
 c	Parameters for helicity sums in matrixN.f
 c*************************************************************************
       REAL*8 LIMHEL
-      PARAMETER(LIMHEL=1e-8) ! ME threshold for helicity filtering
+c     PARAMETER(LIMHEL=1e-8) ! ME threshold for helicity filtering (Fortran default)
+      PARAMETER(LIMHEL=0) ! ME threshold for helicity filtering (force Fortran to mimic cudacpp, see #419)
       INTEGER MAXTRIES
       PARAMETER(MAXTRIES=25)
 C     To pass the helicity configuration chosen by the DiscreteSampler to 
diff --git b/epochX/cudacpp/gg_tt.mad/Source/makefile a/epochX/cudacpp/gg_tt.mad/Source/makefile
index 617f10b93..00c73099a 100644
--- b/epochX/cudacpp/gg_tt.mad/Source/makefile
+++ a/epochX/cudacpp/gg_tt.mad/Source/makefile
@@ -120,7 +120,7 @@ $(LIBDIR)libiregi.a: $(IREGIDIR)
 	cd $(IREGIDIR); make
 	ln -sf ../Source/$(IREGIDIR)libiregi.a $(LIBDIR)libiregi.a
 
-clean:
+cleanSource:
 	$(RM) *.o $(LIBRARIES) $(BINARIES)
 	cd PDF; make clean; cd ..
 	cd PDF/gammaUPC; make clean; cd ../../
@@ -132,4 +132,11 @@ clean:
 	cd BIAS/ptj_bias; make clean; cd ../..
 	if [ -d $(CUTTOOLSDIR) ]; then cd $(CUTTOOLSDIR); make clean; cd ..; fi
 	if [ -d $(IREGIDIR) ]; then cd $(IREGIDIR); make clean; cd ..; fi
+
+clean: cleanSource
 	for i in `ls -d ../SubProcesses/P*`; do cd $$i; make clean; cd -; done;
+
+cleanavx:
+	for i in `ls -d ../SubProcesses/P*`; do cd $$i; make cleanavxs; cd -; done;
+cleanall: cleanSource # THIS IS THE ONE
+	for i in `ls -d ../SubProcesses/P*`; do cd $$i; make cleanavxs; cd -; done;
diff --git b/epochX/cudacpp/gg_tt.mad/SubProcesses/makefile a/epochX/cudacpp/gg_tt.mad/SubProcesses/makefile
index 348c283be..504e41ea5 100644
--- b/epochX/cudacpp/gg_tt.mad/SubProcesses/makefile
+++ a/epochX/cudacpp/gg_tt.mad/SubProcesses/makefile
@@ -1,6 +1,40 @@
+SHELL := /bin/bash
+
 include ../../Source/make_opts
+
+# Export the relevant settings from make_opts to builds using the cudacpp makefile
+export FPTYPE
+
+# Determine CUDACPP_BUILDDIR based on the user-defined choices of BACKEND, FPTYPE, HELINL, HRDCOD and USEBUILDDIR (#829)
+# Stop with an error if BACKEND=cuda and nvcc is missing or if BACKEND=hip and hipcc is missing
+include ../../src/cudacpp_config.mk
+ifeq ($(CUDACPP_BUILDDIR),)
+$(error CUDACPP_BUILDDIR='$(CUDACPP_BUILDDIR)' should not be empty!)
+endif
+
+# Disable all Fortran warnings?
 FFLAGS+= -w
 
+# Enable the C preprocessor https://gcc.gnu.org/onlinedocs/gfortran/Preprocessing-Options.html
+FFLAGS+= -cpp
+
+# Compile counters with -O3 as in the cudacpp makefile (avoid being "unfair" to Fortran #740)
+CXXFLAGS = -O3 -Wall -Wshadow -Wextra
+
+# Add -std=c++17 explicitly to avoid build errors on macOS
+# Add -mmacosx-version-min=11.3 to avoid "ld: warning: object file was built for newer macOS version than being linked"
+ifneq ($(shell $(CXX) --version | egrep '^Apple clang'),)
+CXXFLAGS += -std=c++17 -mmacosx-version-min=11.3
+endif
+
+# Enable ccache for C++ if USECCACHE=1 (do not enable it for Fortran since it is not supported for Fortran)
+ifeq ($(USECCACHE)$(shell echo $(CXX) | grep ccache),1)
+  override CXX:=ccache $(CXX)
+endif
+###ifeq ($(USECCACHE)$(shell echo $(FC) | grep ccache),1)
+###  override FC:=ccache $(FC)
+###endif
+
 # Load additional dependencies of the bias module, if present
 ifeq (,$(wildcard ../bias_dependencies))
 BIASDEPENDENCIES =
@@ -24,7 +58,20 @@ else
     MADLOOP_LIB =
 endif
 
-LINKLIBS = $(LINK_MADLOOP_LIB) $(LINK_LOOP_LIBS) -L../../lib/ -ldhelas -ldsample -lmodel -lgeneric -lpdf -lgammaUPC -lcernlib $(llhapdf) -lbias 
+LINKLIBS = $(LINK_MADLOOP_LIB) $(LINK_LOOP_LIBS) -L$(LIBDIR) -ldhelas -ldsample -lmodel -lgeneric -lpdf -lcernlib $(llhapdf) -lbias 
+
+CUDACPP_MAKEFILE=cudacpp.mk
+processid_short=$(shell basename $(CURDIR) | awk -F_ '{print $$(NF-1)"_"$$NF}')
+ifeq ($(BACKEND),cuda)
+CUDACPP_COMMONLIB=mg5amc_common_cuda
+CUDACPP_BACKENDLIB=mg5amc_$(processid_short)_cuda
+else ifeq ($(BACKEND),hip)
+CUDACPP_COMMONLIB=mg5amc_common_hip
+CUDACPP_BACKENDLIB=mg5amc_$(processid_short)_hip
+else
+CUDACPP_COMMONLIB=mg5amc_common_cpp
+CUDACPP_BACKENDLIB=mg5amc_$(processid_short)_cpp
+endif
 
 LIBS = $(LIBDIR)libbias.$(libext) $(LIBDIR)libdhelas.$(libext) $(LIBDIR)libdsample.$(libext) $(LIBDIR)libgeneric.$(libext) $(LIBDIR)libpdf.$(libext) $(LIBDIR)libgammaUPC.$(libext) $(LIBDIR)libmodel.$(libext) $(LIBDIR)libcernlib.$(libext) $(MADLOOP_LIB) $(LOOP_LIBS)
 
@@ -43,41 +90,147 @@ ifeq ($(strip $(MATRIX_HEL)),)
 endif
 
 
-PROCESS= driver.o myamp.o genps.o unwgt.o setcuts.o get_color.o \
+PROCESS= myamp.o genps.o unwgt.o setcuts.o get_color.o \
          cuts.o cluster.o reweight.o initcluster.o addmothers.o setscales.o \
-	 idenparts.o dummy_fct.o \
-         $(patsubst %.f,%.o,$(wildcard auto_dsig*.f)) \
+	 idenparts.o dummy_fct.o
+
+DSIG=driver.o $(patsubst %.f, %.o, $(filter-out auto_dsig.f, $(wildcard auto_dsig*.f)))
+DSIG_cudacpp=driver_cudacpp.o $(patsubst %.f, %_cudacpp.o, $(filter-out auto_dsig.f, $(wildcard auto_dsig*.f)))
 
 SYMMETRY = symmetry.o idenparts.o 
 
 # Binaries
 
-$(PROG): $(PROCESS) auto_dsig.o $(LIBS) $(MATRIX)
-	$(FC) -o $(PROG) $(PROCESS) $(MATRIX) $(LINKLIBS) $(LDFLAGS) $(BIASDEPENDENCIES) -fopenmp
+ifeq ($(UNAME),Darwin)
+LDFLAGS += -lc++ # avoid 'Undefined symbols' for chrono::steady_clock on macOS (checked with otool -L libmg5amc_gg_ttx_cpp.so) 
+LDFLAGS += -mmacosx-version-min=11.3 # avoid "ld: warning: object file was built for newer macOS version than being linked"  
+else
+LDFLAGS += -Wl,--no-relax # avoid 'failed to convert GOTPCREL relocation' error #458 (not supported on macOS)
+endif
 
-$(PROG)_forhel: $(PROCESS) auto_dsig.o $(LIBS) $(MATRIX_HEL)
-	$(FC) -o $(PROG)_forhel $(PROCESS) $(MATRIX_HEL) $(LINKLIBS) $(LDFLAGS) $(BIASDEPENDENCIES) -fopenmp
+# Explicitly define the default goal (this is not necessary as it is the first target, which is implicitly the default goal)
+.DEFAULT_GOAL := all
 
-gensym: $(SYMMETRY) configs.inc $(LIBS)
-	$(FC) -o gensym $(SYMMETRY) -L../../lib/ $(LINKLIBS) $(LDFLAGS)
+ifeq ($(BACKEND),cuda)
+all: $(PROG)_fortran $(CUDACPP_BUILDDIR)/$(PROG)_cuda
+else ifeq ($(BACKEND),hip)
+all: $(PROG)_fortran $(CUDACPP_BUILDDIR)/$(PROG)_hip
+else
+all: $(PROG)_fortran $(CUDACPP_BUILDDIR)/$(PROG)_cpp
+endif
 
-$(LIBDIR)libmodel.$(libext): ../../Cards/param_card.dat
-	cd ../../Source/MODEL; make
+ifneq ($(shell $(CXX) --version | egrep '^Intel'),)
+override OMPFLAGS = -fopenmp
+LINKLIBS += -liomp5 # see #578
+LINKLIBS += -lintlc # undefined reference to `_intel_fast_memcpy'
+else ifneq ($(shell $(CXX) --version | egrep '^clang'),)
+override OMPFLAGS = -fopenmp
+$(CUDACPP_BUILDDIR)/$(PROG)_cpp: LINKLIBS += -L $(shell dirname $(shell $(CXX) -print-file-name=libc++.so)) -lomp # see #604
+else ifneq ($(shell $(CXX) --version | egrep '^Apple clang'),)
+override OMPFLAGS = # OMP is not supported yet by cudacpp for Apple clang
+else
+override OMPFLAGS = -fopenmp
+endif
 
-$(LIBDIR)libgeneric.$(libext): ../../Cards/run_card.dat
+$(PROG)_fortran: $(PROCESS) $(DSIG) auto_dsig.o $(LIBS) $(MATRIX) counters.o ompnumthreads.o
+	$(FC) -o $(PROG)_fortran $(PROCESS) $(DSIG) auto_dsig.o $(MATRIX) $(LINKLIBS) $(BIASDEPENDENCIES) $(OMPFLAGS) counters.o ompnumthreads.o $(LDFLAGS)
+
+$(LIBS): .libs
+
+.libs: ../../Cards/param_card.dat ../../Cards/run_card.dat
 	cd ../../Source; make
+	touch $@
+
+$(CUDACPP_BUILDDIR)/.cudacpplibs:
+	$(MAKE) -f $(CUDACPP_MAKEFILE)
+	touch $@
+
+# On Linux, set rpath to LIBDIR to make it unnecessary to use LD_LIBRARY_PATH
+# Use relative paths with respect to the executables ($ORIGIN on Linux)
+# On Darwin, building libraries with absolute paths in LIBDIR makes this unnecessary
+ifeq ($(UNAME_S),Darwin)
+  override LIBFLAGSRPATH =
+else ifeq ($(USEBUILDDIR),1)
+  override LIBFLAGSRPATH = -Wl,-rpath,'$$ORIGIN/../$(LIBDIR)/$(CUDACPP_BUILDDIR)'
+else
+  override LIBFLAGSRPATH = -Wl,-rpath,'$$ORIGIN/$(LIBDIR)'
+endif
+
+.PHONY: madevent_fortran_link madevent_cuda_link madevent_hip_link madevent_cpp_link
+
+madevent_fortran_link: $(PROG)_fortran
+	rm -f $(PROG)
+	ln -s $(PROG)_fortran $(PROG)
+
+madevent_cudacpp_link: all
+	rm -f $(PROG)
+ifeq ($(BACKEND),cuda)
+	ln -s $(CUDACPP_BUILDDIR)/$(PROG)_cuda $(PROG)
+else ifeq ($(BACKEND),hip)
+	ln -s $(CUDACPP_BUILDDIR)/$(PROG)_hip $(PROG)
+else
+	ln -s $(CUDACPP_BUILDDIR)/$(PROG)_cpp $(PROG)
+endif
+
+madevent_cuda_link:
+	$(MAKE) USEGTEST=0 USEBUILDDIR=1 BACKEND=cuda madevent_cudacpp_link
 
-$(LIBDIR)libpdf.$(libext): 
-	cd ../../Source/PDF; make
+madevent_hip_link:
+	$(MAKE) USEGTEST=0 USEBUILDDIR=1 BACKEND=hip madevent_cudacpp_link
 
-$(LIBDIR)libgammaUPC.$(libext):
-	cd ../../Source/PDF/gammaUPC; make
+madevent_cpp_link:
+	$(MAKE) USEGTEST=0 USEBUILDDIR=1 BACKEND=cppauto madevent_cudacpp_link
+
+override SUPPORTED_AVXS = cppnone cppsse4 cppavx2 cpp512y cpp512z cppauto
+madevent_%_link:
+	@if [ '$(words $(filter $*, $(SUPPORTED_AVXS)))' != '1' ]; then echo "ERROR! Invalid target '$@' (supported madevent_cpp*_link targets are: $(foreach avx,$(SUPPORTED_AVXS),'madevent_$(avx)_link'))"; exit 1; fi
+	$(MAKE) USEGTEST=0 USEBUILDDIR=1 BACKEND=$* madevent_cudacpp_link
+
+# Building $(PROG)_cpp no longer builds $(PROG)_cuda if CUDACPP_BACKENDLIB for cuda exists (this was the case in the past to allow cpp-only builds #503)
+$(CUDACPP_BUILDDIR)/$(PROG)_cpp: $(PROCESS) $(DSIG_cudacpp) auto_dsig.o $(LIBS) $(MATRIX) counters.o ompnumthreads.o $(CUDACPP_BUILDDIR)/.cudacpplibs
+	$(FC) -o $@ $(PROCESS) $(DSIG_cudacpp) auto_dsig.o $(MATRIX) $(LINKLIBS) $(BIASDEPENDENCIES) $(OMPFLAGS) counters.o ompnumthreads.o -L$(LIBDIR)/$(CUDACPP_BUILDDIR) -l$(CUDACPP_COMMONLIB) -l$(CUDACPP_BACKENDLIB) $(LIBFLAGSRPATH) $(LDFLAGS)
+
+# Building $(PROG)_cuda now uses its own rule
+$(CUDACPP_BUILDDIR)/$(PROG)_cuda: $(PROCESS) $(DSIG_cudacpp) auto_dsig.o $(LIBS) $(MATRIX) counters.o ompnumthreads.o $(CUDACPP_BUILDDIR)/.cudacpplibs
+	$(FC) -o $@ $(PROCESS) $(DSIG_cudacpp) auto_dsig.o $(MATRIX) $(LINKLIBS) $(BIASDEPENDENCIES) $(OMPFLAGS) counters.o ompnumthreads.o -L$(LIBDIR)/$(CUDACPP_BUILDDIR) -l$(CUDACPP_COMMONLIB) -l$(CUDACPP_BACKENDLIB) $(LIBFLAGSRPATH) $(LDFLAGS)
+
+# Building $(PROG)_hip also uses its own rule
+$(CUDACPP_BUILDDIR)/$(PROG)_hip: $(PROCESS) $(DSIG_cudacpp) auto_dsig.o $(LIBS) $(MATRIX) counters.o ompnumthreads.o $(CUDACPP_BUILDDIR)/.cudacpplibs
+	$(FC) -o $@ $(PROCESS) $(DSIG_cudacpp) auto_dsig.o $(MATRIX) $(LINKLIBS) $(BIASDEPENDENCIES) $(OMPFLAGS) counters.o ompnumthreads.o -L$(LIBDIR)/$(CUDACPP_BUILDDIR) -l$(CUDACPP_COMMONLIB) -l$(CUDACPP_BACKENDLIB) $(LIBFLAGSRPATH) $(LDFLAGS)
+
+counters.o: counters.cc timer.h
+	$(CXX) $(CXXFLAGS) -c $< -o $@
+
+ompnumthreads.o: ompnumthreads.cc ompnumthreads.h
+	$(CXX) -I. $(CXXFLAGS) $(OMPFLAGS) -c $< -o $@
+
+$(PROG)_forhel: $(PROCESS) auto_dsig.o $(LIBS) $(MATRIX_HEL)
+	$(FC) -o $(PROG)_forhel $(PROCESS) $(MATRIX_HEL) $(LINKLIBS) $(LDFLAGS) $(BIASDEPENDENCIES) $(OMPFLAGS)
+
+gensym: $(SYMMETRY) configs.inc $(LIBS)
+	$(FC) -o gensym $(SYMMETRY) -L$(LIBDIR) $(LINKLIBS) $(LDFLAGS)
+
+###ifeq (,$(wildcard fbridge.inc)) # Pointless: fbridge.inc always exists as this is the cudacpp-modified makefile!
+###$(LIBDIR)libmodel.$(libext): ../../Cards/param_card.dat
+###	cd ../../Source/MODEL; make
+###
+###$(LIBDIR)libgeneric.$(libext): ../../Cards/run_card.dat
+###	cd ../../Source; make
+###
+###$(LIBDIR)libpdf.$(libext): 
+###	cd ../../Source/PDF; make
+###
+###$(LIBDIR)libgammaUPC.$(libext):
+###	cd ../../Source/PDF/gammaUPC; make
+###endif
 
 # Add source so that the compiler finds the DiscreteSampler module.
 $(MATRIX): %.o: %.f
 	$(FC) $(FFLAGS) $(MATRIX_FLAG) -c $< -I../../Source/ -I../../Source/PDF/gammaUPC
 %.o: %.f
 	$(FC) $(FFLAGS) -c $< -I../../Source/ -I../../Source/PDF/gammaUPC
+%_cudacpp.o: %.f
+	$(FC) $(FFLAGS) -c -DMG5AMC_MEEXPORTER_CUDACPP $< -I../../Source/ $(OMPFLAGS) -o $@
 
 # Dependencies
 
@@ -97,5 +250,80 @@ unwgt.o: genps.inc nexternal.inc symswap.inc cluster.inc run.inc message.inc \
 	 run_config.inc
 initcluster.o: message.inc
 
-clean:
-	$(RM) *.o gensym madevent madevent_forhel
+# Extra dependencies on discretesampler.mod
+
+auto_dsig.o: .libs
+driver.o: .libs
+driver_cudacpp.o: .libs
+$(MATRIX): .libs
+genps.o: .libs
+
+# Cudacpp bldall targets
+
+ifeq ($(UNAME_P),ppc64le)
+bldavxs: bldnone bldsse4
+else ifeq ($(UNAME_P),arm)
+bldavxs: bldnone bldsse4
+else
+bldavxs: bldnone bldsse4 bldavx2 bld512y bld512z
+endif
+
+ifneq ($(shell which hipcc 2>/dev/null),)
+ifneq ($(shell which nvcc 2>/dev/null),)
+bldall: bldhip bldcuda bldavxs
+else
+bldall: bldhip bldavxs
+endif
+else
+ifneq ($(shell which nvcc 2>/dev/null),)
+bldall: bldcuda bldavxs
+else
+bldall: bldavxs
+endif
+endif
+
+bldcuda: $(PROG)_fortran $(DSIG_cudacpp)
+	@echo
+	$(MAKE) USEBUILDDIR=1 BACKEND=cuda
+
+bldhip: $(PROG)_fortran $(DSIG_cudacpp)
+	@echo
+	$(MAKE) USEBUILDDIR=1 BACKEND=hip
+
+bldnone: $(PROG)_fortran $(DSIG_cudacpp)
+	@echo
+	$(MAKE) USEBUILDDIR=1 BACKEND=cppnone
+
+bldsse4: $(PROG)_fortran $(DSIG_cudacpp)
+	@echo
+	$(MAKE) USEBUILDDIR=1 BACKEND=cppsse4
+
+bldavx2: $(PROG)_fortran $(DSIG_cudacpp)
+	@echo
+	$(MAKE) USEBUILDDIR=1 BACKEND=cppavx2
+
+bld512y: $(PROG)_fortran $(DSIG_cudacpp)
+	@echo
+	$(MAKE) USEBUILDDIR=1 BACKEND=cpp512y
+
+bld512z: $(PROG)_fortran $(DSIG_cudacpp)
+	@echo
+	$(MAKE) USEBUILDDIR=1 BACKEND=cpp512z
+
+# Clean (NB: 'make clean' in Source calls 'make clean' in all P*)
+
+clean: # Clean builds: fortran in this Pn; cudacpp executables for one AVX in this Pn
+	$(RM) *.o gensym $(PROG) $(PROG)_fortran $(PROG)_forhel $(CUDACPP_BUILDDIR)/$(PROG)_cpp $(CUDACPP_BUILDDIR)/$(PROG)_cuda $(CUDACPP_BUILDDIR)/$(PROG)_hip
+
+cleanavxs: clean # Clean builds: fortran in this Pn; cudacpp for all AVX in this Pn and in src
+	$(MAKE) -f $(CUDACPP_MAKEFILE) cleanall
+	rm -f $(CUDACPP_BUILDDIR)/.cudacpplibs
+	rm -f .libs
+
+cleanall: # Clean builds: fortran in all P* and in Source; cudacpp for all AVX in all P* and in src
+	make -C ../../Source cleanall
+	rm -rf $(LIBDIR)libbias.$(libext)
+	rm -f ../../Source/*.mod ../../Source/*/*.mod
+
+distclean: cleanall # Clean all fortran and cudacpp builds as well as the googletest installation
+	$(MAKE) -f $(CUDACPP_MAKEFILE) distclean
