//==========================================================================
// Copyright (C) 2023-2025 CERN
// Licensed under the GNU Lesser General Public License (version 3 or later).
// Written by: Z. Wettersten (Jan 2024) for the MG5aMC CUDACPP plugin.
//==========================================================================
//==========================================================================
// Library including generic functions and classes for event reweighting.
// Process-specific rwgt_runner files are generated by mg5amc@nlo and use
// this library, while the rwgt_driver file is a wrapping program that
// calls the process-specific runners for given subprocesses.
//==========================================================================

#ifndef _RWGT_INSTANCE_H_
#define _RWGT_INSTANCE_H_

#include "teaRex.h"

/**
 * The floating point precision used in Fortran arrays.
 * This is presently hardcoded to double precision (REAL*8).
 */
using FORTRANFPTYPE = double; // for Fortran double precision (REAL*8) arrays
// using FORTRANFPTYPE = float; // for Fortran single precision (REAL*4) arrays

namespace rwgt
{

    // ZW: Function for calculating the number of remaining events in a warp
    //  in order to pad the input arrays to a multiple of the warp size
    unsigned int warpRemain(unsigned int nEvt, unsigned int nWarp = 32);

    // ZW: bridgeWrapper needs args: nEvs, nPar, nMom, moms, gs, rndhel, rndcol, selhel, selcol, chanId
    using bridgeWrapper = std::function<std::shared_ptr<std::vector<FORTRANFPTYPE>>(int &, int &, int &, std::vector<FORTRANFPTYPE> &, std::vector<FORTRANFPTYPE> &, std::vector<FORTRANFPTYPE> &, std::vector<FORTRANFPTYPE> &, std::vector<int> &, std::vector<int> &, unsigned int &, bool &)>;

    struct fBridge
    {
        // Default constructors
        fBridge() = default;
        fBridge(const fBridge &source) = default;
        fBridge(fBridge &&source) = default;

        std::vector<FORTRANFPTYPE> rndHel = {};
        std::vector<FORTRANFPTYPE> rndCol = {};
        std::vector<FORTRANFPTYPE> gs = {};
        std::vector<int> selHel = {};
        std::vector<int> selCol = {};
        unsigned int chanId = 0;
        int nMom = 4;
        int nWarp;
        int nWarpRemain;
        int nEvt;
        int fauxNEvt;
        int nPar;
        bool goodHel = false;
        bridgeWrapper bridge;
        fBridge(REX::process &proc, unsigned int warpSize = 32);
        fBridge(std::shared_ptr<REX::process> proc, unsigned int warpSize = 32);
        void init(std::vector<REX::event> &process, unsigned int warpSize = 32);
        void init(std::vector<std::shared_ptr<REX::event>> process, unsigned int warpSize = 32);
        void bridgeSetup(unsigned int &noEvts, unsigned int warpSize = 32);
        void bridgeSetup(std::vector<FORTRANFPTYPE> &evVec, unsigned int warpSize = 32);
        void bridgeSetup(std::shared_ptr<std::vector<FORTRANFPTYPE>> &evVec, unsigned int warpSize = 32);
        void bridgeSetup(REX::process &proc, unsigned int warpSize = 32);
        void bridgeSetup(std::shared_ptr<REX::process> proc, unsigned int warpSize = 32);
        void setBridge(bridgeWrapper amp);
        std::shared_ptr<std::vector<FORTRANFPTYPE>> bridgeCall(std::vector<FORTRANFPTYPE> &momenta);
        std::shared_ptr<std::vector<FORTRANFPTYPE>> bridgeCall(REX::process &process);
        std::shared_ptr<std::vector<FORTRANFPTYPE>> bridgeCall(std::shared_ptr<REX::process> process);
        REX::tea::weightor getAmp();
    };

}

#endif