//==========================================================================
// Copyright (C) 2023-2025 CERN
// Licensed under the GNU Lesser General Public License (version 3 or later).
// Written by: Z. Wettersten (Jan 2024) for the MG5aMC CUDACPP plugin.
//==========================================================================
//==========================================================================
// Library including generic functions and classes for event reweighting.
// Process-specific rwgt_runner files are generated by mg5amc@nlo and use
// this library, while the rwgt_driver file is a wrapping program that
// calls the process-specific runners for given subprocesses.
//==========================================================================

#ifndef _RWGT_INSTANCE_CC_
#define _RWGT_INSTANCE_CC_

#include "rwgt_instance.h"

namespace rwgt
{

    // ZW: Function for calculating the number of remaining events in a warp
    //  in order to pad the input arrays to a multiple of the warp size
    unsigned int warpRemain(unsigned int nEvt, unsigned int nWarp)
    {
        return (nWarp - (nEvt % nWarp)) % nWarp;
    }

    // ZW: Function for padding the input arrays to a multiple of the warp size
    template <typename T>
    void warpPad(std::vector<T> &input, unsigned int nWarp = 32)
    {
        auto nEvt = input.size();
        auto nWarpRemain = warpRemain(nEvt, nWarp);
        input.reserve(nEvt + nWarpRemain);
        for (size_t k = nEvt - nWarpRemain; k < nEvt; ++k)
        {
            input.push_back(input[k]);
        }
        return;
    }

    fBridge::fBridge(REX::process &proc, unsigned int warpSize)
    {
        this->nPar = proc.events[0]->view().size();
        this->nEvt = proc.events.size();
        this->nWarp = warpSize;
        this->nWarpRemain = warpRemain(nEvt, nWarp);
        this->fauxNEvt = nEvt + nWarpRemain;
        this->gs = proc.gS();
        this->rndHel = std::vector<FORTRANFPTYPE>(fauxNEvt, 0.);
        this->rndCol = std::vector<FORTRANFPTYPE>(fauxNEvt, 0.);
        this->selHel = std::vector<int>(fauxNEvt, 0.);
        this->selCol = std::vector<int>(fauxNEvt, 0.);
        this->goodHel = false;
    }

    fBridge::fBridge(std::shared_ptr<REX::process> proc, unsigned int warpSize)
    {
        if (proc == nullptr)
        {
            throw std::runtime_error("fBridge: Provided process is null or contains no subprocesses.");
        }
        // Assuming all subprocesses have the same number of particles
        this->nPar = proc->events[0]->view().size();
        this->nEvt = proc->events.size();
        this->nWarp = warpSize;
        this->nWarpRemain = warpRemain(nEvt, nWarp);
        this->fauxNEvt = nEvt + nWarpRemain;
        this->gs = proc->gS();
        this->rndHel = std::vector<FORTRANFPTYPE>(fauxNEvt, 0.);
        this->rndCol = std::vector<FORTRANFPTYPE>(fauxNEvt, 0.);
        this->selHel = std::vector<int>(fauxNEvt, 0.);
        this->selCol = std::vector<int>(fauxNEvt, 0.);
        this->goodHel = false;
    }

    void fBridge::bridgeSetup(unsigned int &noEvts, unsigned int warpSize)
    {
        this->nEvt = noEvts;
        this->nWarp = warpSize;
        this->nWarpRemain = warpRemain(nEvt, nWarp);
        this->fauxNEvt = nEvt + nWarpRemain;
        this->rndHel = std::vector<FORTRANFPTYPE>(fauxNEvt, 0.);
        this->rndCol = std::vector<FORTRANFPTYPE>(fauxNEvt, 0.);
        this->selHel = std::vector<int>(fauxNEvt, 0.);
        this->selCol = std::vector<int>(fauxNEvt, 0.);
    }
    void fBridge::bridgeSetup(std::vector<FORTRANFPTYPE> &evVec, unsigned int warpSize)
    {
        this->nEvt = evVec.size();
        this->nWarp = warpSize;
        this->nWarpRemain = warpRemain(nEvt, nWarp);
        this->fauxNEvt = nEvt + nWarpRemain;
        this->rndHel = std::vector<FORTRANFPTYPE>(fauxNEvt, 0.);
        this->rndCol = std::vector<FORTRANFPTYPE>(fauxNEvt, 0.);
        this->selHel = std::vector<int>(fauxNEvt, 0.);
        this->selCol = std::vector<int>(fauxNEvt, 0.);
    }
    void fBridge::bridgeSetup(std::shared_ptr<std::vector<FORTRANFPTYPE>> &evVec, unsigned int warpSize)
    {
        this->bridgeSetup(*evVec, warpSize);
    }

    void fBridge::bridgeSetup(REX::process &proc, unsigned int warpSize)
    {
        this->nPar = proc.events[0]->view().size();
        this->nEvt = proc.events.size();
        this->nWarp = warpSize;
        this->nWarpRemain = warpRemain(nEvt, nWarp);
        this->fauxNEvt = nEvt + nWarpRemain;
        this->gs = proc.gS();
        this->rndHel = std::vector<FORTRANFPTYPE>(fauxNEvt, 0.);
        this->rndCol = std::vector<FORTRANFPTYPE>(fauxNEvt, 0.);
        this->selHel = std::vector<int>(fauxNEvt, 0.);
        this->selCol = std::vector<int>(fauxNEvt, 0.);
        this->goodHel = false;
    }

    void fBridge::bridgeSetup(std::shared_ptr<REX::process> proc, unsigned int warpSize)
    {
        this->bridgeSetup(*proc, warpSize);
    }

    void fBridge::setBridge(bridgeWrapper amp)
    {
        if (this->bridge == nullptr)
        {
            this->bridge = amp;
        }
        else
            throw std::runtime_error("fBridge object doubly defined.");
    }
    std::shared_ptr<std::vector<FORTRANFPTYPE>> fBridge::bridgeCall(std::vector<FORTRANFPTYPE> &momenta)
    {
        if (this->nEvt == 0)
            this->bridgeSetup(this->gs);
        if (this->bridge == nullptr)
            throw std::runtime_error("fBridge object not defined.");
        if (this->gs.size() != fauxNEvt)
            warpPad(gs, nWarp);
        warpPad(momenta, nWarp * nPar * nMom);
        auto evalScatAmps = this->bridge(
            fauxNEvt, nPar, nMom,
            momenta, gs, rndHel, rndCol,
            selHel, selCol, chanId, goodHel);
        momenta.resize(nEvt * nPar * nMom);
        evalScatAmps->resize(nEvt);
        return evalScatAmps;
    }

    std::shared_ptr<std::vector<FORTRANFPTYPE>> fBridge::bridgeCall(REX::process &proc)
    {
        if (this->nEvt == 0)
            this->bridgeSetup(proc);
        return this->bridgeCall(proc.momenta_.flat_vector());
    }

    std::shared_ptr<std::vector<FORTRANFPTYPE>> fBridge::bridgeCall(std::shared_ptr<REX::process> proc)
    {
        return this->bridgeCall(proc->momenta_.flat_vector());
    }

    REX::tea::weightor fBridge::getAmp()
    {
        if (this->bridge == nullptr)
            throw std::runtime_error("fBridge object not defined.");
        REX::tea::weightor amp = [this](REX::process &process)
        {
            return this->bridgeCall(process);
        };
        return amp;
    }

}

#endif
